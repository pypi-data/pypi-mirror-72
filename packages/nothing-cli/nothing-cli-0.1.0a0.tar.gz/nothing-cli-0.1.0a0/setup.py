# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['nothing_cli', 'nothing_cli.localization', 'nothing_cli.tests']

package_data = \
{'': ['*']}

install_requires = \
['colorama>=0.4.3,<0.5.0',
 'pydantic>=1.4,<2.0',
 'python-slugify>=4.0.0,<5.0.0',
 'ruamel.yaml>=0.16.10,<0.17.0',
 'typer>=0.1.0,<0.2.0',
 'typing-extensions>=3.7.4,<4.0.0']

entry_points = \
{'console_scripts': ['not = nothing_cli.main:app']}

setup_kwargs = {
    'name': 'nothing-cli',
    'version': '0.1.0a0',
    'description': 'Nothing helps coder be more smarter & less dumber.',
    'long_description': '# Nothing (`not`)\n\nNothing helps coders be more smarter, some cooler, less dumber, and much faster. `not`.\n\nTake hold of the key 🔑 to gradual automation.\n\n\n## Installation\n\n`nothing-cli` is very young, only an infant. 🐣\n\nIf you\'d like to give it a try, it\'s available in alpha on PyPi.\n\n```shell\npip install nothing-cli\n```\n\nIn part due to its youth, only Python 3.7 and above are supported. 😬\n\n\nThe command for interacting with the tool is `not`. Get the overview of its subcommands like so:\n\n```shell\nnot --help\n```\n\nGet a quick first taste by running:\n\n```python\nnot sample\n```\n\nYou should now have a sample Procedure available, aptly named `nothing`. Get an overview of what it does and where it lives with the `describe` subcommand:\n\n```shell\nnot describe nothing\n```\n\nYou can invoke it with the `do` subcommand:\n\n```shell\nnot do nothing\n```\n\nYou\'ll be walked through the Procedure for doing... nothing. Enjoy! Folks don\'t do enough nothing, in my opinion.\n\n## Overview\n\n### A Realistic Example\n\nThe central concept of `nothing-cli` is the *Procedure*. A Procedure is simply a `yaml` file in a `.nothing` directory. We interact with them with the `not` command.\n\nProcedures are not quite todo lists, not quite instructions, and not quite forms. The idea is to use them for infrequent, "toilsome" tasks that are easy to get lost in, annoying to document, and hard ––but very enticing–– to automate.\n\nHere\'s a simple Procedure for a developer\'s personal checklist before starting work on a new feature branch:\n\n```yaml\n---\ntitle: Get started with a feature branch\ndescription: A few preflight checks before you start coding\ncontext:\n  - dev_goal: Briefly, what do you want to accomplish with this branch?\n  - __feature_branch_name: What name did you come up with for the new branch?\nknowns:\n  - main_branch: master\nsteps: |-\n  Check out the main branch and get the latest changes:\n  git checkout {main_branch} && git pull\n\n  Think of a short, kebab-cased name that captures your goal:\n  "{dev_goal}"\n\n  Create the new branch:\n  git checkout -b {__feature_branch_name}\n\n  Push the new branch to the remote:\n  git push -u {__feature_branch_name}\n```\n\nIf you copy and paste the above into a file called `preflight-checks.yml` and save it in a directory called `.nothing` (either in your home or working directory), then you can "do" the Procedure by calling:\n\n```shell\nnot do preflight-checks\n```\n\nFor those without a terminal handy, it\'d look like this:\n\n[![asciicast](https://asciinema.org/a/cbLdJ1QCAhHzOuLsHWwZ4fr0e.svg)](https://asciinema.org/a/cbLdJ1QCAhHzOuLsHWwZ4fr0e)\n\n## Inspo & Rationale\n\nOnce upon a time, we all read this article about ["do-nothing scripting"](https://blog.danslimmon.com/2019/07/15/do-nothing-scripting-the-key-to-gradual-automation/) by Dan Slimmon.\n\nIt\'s an incredible concept. I\'ve personally wasted hours of my life trying to turn ever-more-complex aliases into [shell functions](https://github.com/ainsleymcgrath/bin/blob/master/.pydev.sh). I\'ve spent days attempting to automate scripts to do extremely infrequent –but highly toilsome– tasks that [probably would not even have taken hours manually](https://github.com/ainsleymcgrath/dotfiles/commit/46add94cb7b5ad068fd7b23fc8305aba85c63762).\n\n"Toil," as Slimmon terms it, sucks. We\'ll do anything to get away from it. Do-nothing scripts are a place to meet halfway: Nowhere near the cognitive overhead of writing an actual automation script, but more interactive and dynamic than pure documentation.\n\nBut, even logic-free & sugary sweet do-nothing scripts are written in the language of your choice can be fragile. Your stylistic decisions rot. There\'s no formality to creation or maintenance. Hardcoded strings sprinkled on off-the-cuff implementation. Suddenly, toil returns. Utility vanishes.\n\nRealizing this as my team and my friends experimented more with the practice, I did the logical thing: I wrote an entire piece of software to automate the process of writing the code we write to prevent ourselves from writing too much code to automate stuff when we want to stop *toiling* and just write some freaking code.\n\nIt\'s a noble cause, I think. [Insert infrequent terrible process] always goes faster when you can just ask your teammate for that really specific command and copy-paste. Cut them some slack. Get the command from a terminal robot.\n\n### Pudding (The proof is in it)\n\nHere is the original do-nothing script example from Slimmon\n\n```python\nimport sys\n\ndef wait_for_enter():\n    raw_input("Press Enter to continue: ")\n\nclass CreateSSHKeypairStep(object):\n    def run(self, context):\n        print("Run:")\n        print("   ssh-keygen -t rsa -f ~/{0}".format(context["username"]))\n        wait_for_enter()\n\nclass GitCommitStep(object):\n    def run(self, context):\n        print("Copy ~/new_key.pub into the `user_keys` Git repository, then run:")\n        print("    git commit {0}".format(context["username"]))\n        print("    git push")\n        wait_for_enter()\n\nclass WaitForBuildStep(object):\n    build_url = "http://example.com/builds/user_keys"\n    def run(self, context):\n        print("Wait for the build job at {0} to finish".format(self.build_url))\n        wait_for_enter()\n\nclass RetrieveUserEmailStep(object):\n    dir_url = "http://example.com/directory"\n    def run(self, context):\n        print("Go to {0}".format(self.dir_url))\n        print("Find the email address for user `{0}`".format(context["username"]))\n        context["email"] = raw_input("Paste the email address and press enter: ")\n\nclass SendPrivateKeyStep(object):\n    def run(self, context):\n        print("Go to 1Password")\n        print("Paste the contents of ~/new_key into a new document")\n        print("Share the document with {0}".format(context["email"]))\n        wait_for_enter()\n\nif __name__ == "__main__":\n    context = {"username": sys.argv[1]}\n    procedure = [\n        CreateSSHKeypairStep(),\n        GitCommitStep(),\n        WaitForBuildStep(),\n        RetrieveUserEmailStep(),\n        SendPrivateKeyStep(),\n    ]\n    for step in procedure:\n        step.run(context)\n    print("Done.")\n```\n\nHere it is translated to a `nothing-cli` Procedure:\n\n```yaml\n---\ntitle: Provision New User Account\ndescription: Create and distribute an SSH key for a new user.\ncontext:\n  - username\n  - build_url\n  - dir_url\n  - email: Copy the new user\'s email and paste here\nsteps: |-\n  Run:\n    ssh-keygen -t rsa -f ~/{username}\n\n  Copy ~/new_key.pub into the `user_keys` Git repository, then run:\n    git commit {username}\n    git push\n\n  Wait for the build job at {build_url} to finish:\n\n  Go to 1Password\n  Paste the contents of ~/new_key into a new document\n  Share the document with {email}\n```\n\nI know it\'s impolite to talk about LOC, but the `nothing-cli` procedure version weighs in at 17 to the original 43 (excluding blank lines). The drastically improved readability and editability should speak for itself.\n\n#### Things to Note\n\nYou\'ll notice that context is specified in 2 ways. The first three items are specified using "simple context," where the value is merely a yaml list item. The user is prompted for those values with a default phrase: *Please provide a value for [variable name]*. The last context item uses dictionary syntax, allowing the specification of a friendlier prompt.\n\nNext, the funny looking `|-` next to `steps` specifies a [block scalar](https://yaml-multiline.info/#block-scalars). The very existence of this yaml feature was a great inspiration to create this tool in the first place. It functions as a sort of lawless playground for plain text, supporting:\n\n- Multiline text and indentation.\n- A clear visual delineation of content from configuration\n- The specification of each step as a paragraph, which is is both obvious to read and easy to edit.\n\nIt is worth mentioning, however, that the current version of `nothing-cli` is not able to replicate the original script exactly.\n\nIf you run them side-by-side, you\'ll see that the original uses hard-coded values for `dir_url` and `build_url`. Additionally, the user is prompted for `email` in the middle of the script, rather than at the end. These omissions are discussed in the Planned Features section.\n\n## Planned Features\n\nThe alpha version of `nothing-cli` was meant to be as focused as possible. For this reason, some mechanics of the original do-nothing script were omitted.\n\n#### Promptless Knowns & Context\n\nIn an ideal world, users could specify context as usual:\n\n```yaml\n---\n# diet-review.yml\ncontext:\n  - favorite_food: What\'s your favorite thing to eat?\n```\n\nBut then circumvent the prompt by running the Procedure like this:\n\n```shell\nnot do diet-review --favorite-food \'french omelet\'\n```\n\nEven more useful would be specifying a this for knowns:\n\n```yaml\n---\n# secret-stuff.yml\nknowns:\n  - secret_password\n```\n\nSpecifying a known with no value (as a plain yaml list item) would require the Procedure to be run with the value as a command-line option.\n\n```shell\nnot do secret-stuff # refuses to run\nnot do secret-stuff --secret_password \'n3veR $h4re tHis--\'\n```\n\n#### Chaining Procedures\n\nFor the composition-minded, it could be a boon to write small, related Procedures and have them run directly into each other, maybe even sharing context.\n\nThis could be specified at runtime:\n\n```yaml\nnot do proc-1 --chain proc-2 --chain proc-3\n```\n\nOr in the Procedure itself:\n\n```yaml\n---\n# use-chains.yml\ntitle: Use chains\ndescription: Demonstration of chain usage\ncontext:\n  - name\nsteps: |-\n  Love yourself and your colleagues, {name}.\n\n  Choose composition.\nchain:\n  to: review-chaining\n  pass_context: yes\n```\n\n#### Conditional Chaining\n\nWe\'re getting absolutely crazy here, but adding *several* features could allow for supercharged chains:\n\n```yaml\n---\n# ci-stuff.yml\ntitle: CI/CD Toil\ndescription: Boring CI thing, one day you\'ll automate. But not now.\ncontext:\n  # add syntax for limited choice context\n  - deploy_phase[dev/prod]: What kind of deploy are you doing?\nchain:\n   # use context to determine where chain\n  - if:\n      deploy_phase_is: dev\n      to: dev-deploy\n  - if:\n      deploy_phase_is: prod\n      to: prod-deploy\n```\n\nThis one is surely a moonshot but damn... I wanna do it 🤩\n\n#### And more!\n\nMy head is full of ideas! Perhaps yours is too. If you believe in this tool, drop me a line, I\'ll be overjoyed and say nice things to you. 😸\n',
    'author': 'Ainsley McGrath',
    'author_email': 'mcgrath.ainsley@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': None,
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'entry_points': entry_points,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
