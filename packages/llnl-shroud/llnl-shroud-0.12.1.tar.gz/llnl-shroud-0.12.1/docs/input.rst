.. Copyright (c) 2017-2020, Lawrence Livermore National Security, LLC and
   other Shroud Project Developers.
   See the top-level COPYRIGHT file for details.

   SPDX-License-Identifier: (BSD-3-Clause)

Input
=====

The input to Shroud is a YAML formatted file.
YAML is a human friendly data serialization standard. [yaml]_
Structure is shown through indentation (one or more spaces).  Sequence
items are denoted by a dash, and key value pairs within a map are
separated by a colon:

.. code-block:: yaml

    library: Tutorial

    declarations:
    - decl: typedef int TypeID

    - decl: void Function1()

    - decl: class Class1
      declarations:
      - decl: void Method1()

Each ``decl`` entry corresponds to a line of C or C++ code.  The top
level ``declarations`` field represents the source file while nested
``declarations`` fields corresponds to curly brace blocks.
The above YAML file represent the source file:

.. code-block:: c++

    typedef int TypeID;

    void Function1();

    class Class1
    {
        void Method1();
    }

A ``block`` can be used to group a collection of ``decl`` entires.
Any ``option`` or ``format`` fields will apply to all declarations in
the group:

.. code-block:: yaml

    declarations:
    - block: True
      options:
        F_name_impl_template: {library}_{undescore_name}
      format:
        F_impl_filename: localfile.f
      declarations:
      - decl: void func1()
      - decl: void func2()

Shroud use curly braces for format strings.
If a string starts with a curly brace YAML
will interpret it as a map/dictionary instead of as part of the
string. To avoid this behavior, strings which start with a curly brace
should be quoted:

.. code-block:: yaml

    name : "{fmt}"

Strings may be split across several lines by indenting the continued line:

.. code-block:: yaml

    - decl: void Sum(int len, const int *values+rank(1),
                     int *result+intent(out))

Some values consist of blocks of code.  The pipe, ``|``, is used to indicate that
the string will span several lines and that newlines should be preserved:

.. code-block:: yaml

    C_invalid_name: |
        if (! isNameValid({cxx_var})) {{
            return NULL;
        }}

Note that to insert a literal ``{``, a double brace, ``{{``, is
required since single braces are used for variable expansion.
``{cxx_var}`` in this example.
However, using the pipe, it is not necessary to quote lines that
contain other YAML meta characters such as colon and curly braces.

Literal newlines, ``/n``, are respected.  Format strings can use a
tab, ``/t``, to hint where it would be convenient to add a
continuation if necessary.  A formfeed, ``/f``, will force a
continuation.  Lines which start with ``0`` are not indented.  This
can be used with labels.  A trailing ``+`` will indent then next line
a level and a leading ``-`` will deindent. Line lengths are controlled
by the options *C_line_length* and *F_line_length* and default to
72.:

.. code-block:: yaml

    C_invalid_name: |
        if (! isNameValid({cxx_var})) {{+
        return NULL;
        -}}

The only formatting option is to control output line lengths.  This is
required for Fortran which has a maximum line length of 132 in free
form which is generated by shroud.  If you care where curly braces go
in the C source then it is best to set *C_line_length* to a large
number then use an external formatting tool such as ``indent`` or
``uncrustify``.

Customizing Behavior in the YAML file
-------------------------------------

Fields
^^^^^^

A field only applies to the type, enumeration, function, structure or class
to which it belongs.
It is not inherited.
For example, *cxx_header* is a field which is used to define the header file
for class *Names*.  Likewise, setting *library* within a class does not change
the library name.

.. code-block:: yaml

    library: testnames

    declarations:
      - decl: class Names
        cxx_header: names.hpp
        declarations:
        -  decl: void method1


.. XXX cxx_header is 'inherited' in a sense.

Options
^^^^^^^

Options are used to customize the behavior of Shroud.
They are defined in the YAML file as a dictionary.
Options can be defined at the global, class, or function level.
Each level creates a new scope which can access all upper level options.
This allows the user to modify behavior for all functions or just a single one:

.. code-block:: yaml

    options:
      option_a = false
      option_b = false
      option_c = false

    declarations:
    - class: class1
      options:
    #    option_a = false     # inherited
         option_b = true
    #    option_c = false     # inherited
      declarations:
      - decl: void function1
        options:
    #     option_a = false    # inherited
    #     option_b = true     # inherited
          option_c = true

Format
------

A format dictionary contains strings which can be inserted into
generated code.  Generated filenames are also entries in the format
dictionary.  Format dictionaries are also scoped like options.
For example, setting a format in a class also effects all of the 
functions within the class.

How code is formatted
^^^^^^^^^^^^^^^^^^^^^

Format strings contain “replacement fields” surrounded by curly braces
``{}``. Anything that is not contained in braces is considered literal
text, which is copied unchanged to the output. If you need to include
a brace character in the literal text, it can be escaped by doubling:
``{{`` and ``}}``. [Python_Format]_

There are some metacharacters that are used for formatting the line:

\\f

    Add an explicit formfeed

\\t

    A tab is used to suggest a place to break the line for a continuation
    before it exceeds option *C_line_length* or *F_line_length*.
    Any whitespace after a tab will be trimmed if the line is actually
    split at the tab.  If a continuation was not needed (there was enough
    space on the current line) then the tab has no effect::

        arg1,\t arg2

\+ -

    Increase or decrease indention indention level.
    Used at the beginning or end of a line::

       if (condition) {{+
       do_one();
       -}} else {{+
       do_two();
       -}}

    The double curly braces are replace by a single curly.
    This will be indented as::

       if (condition) {
           do_one();
       } else {
           do_two();
       }

#

       If the first character is a #, ignore indention and write in column 0.
       Useful for preprocessing directives.

^

       If the first character is ^, ignore indention and write in column 0.
       Useful for comments or labels.

@

       If the first character is @, treat the following character literally.
       Used to ignore a metacharacter::

           struct aa = {{++
           0// set field to 0
           @0,
           -}};

       Formatted as::

           struct aa = {
           // set field to 0
               0,
           };


Attributes
----------

Annotations or attributes apply to specific arguments or results.
They describe semantic behavior for an argument.
An attribute may be set to true by listing its name or
it may have a value in parens:

.. code-block:: yaml

    - decl: Class1()  +name(new)
    - decl: void Sum(int len, const int *values+rank(1)+intent(in))
    - decl: const std::string getName() +len(30)

Attributes may also be added external to *decl*:

.. code-block:: yaml

    - decl: void Sum(int len, const int *values)
      attrs:
          values:
              intent: in  
              rank: 1
    - decl: const std::string getName()
      fattrs:
          len: 30

Attributes must be added before default arguments since
a default argument may include a plus symbol:

.. code-block:: yaml

    - decl: void Sum(int len, const int *values+rank(1)+intent(in) =nullptr)

.. While parsing, attribute values are saved by finding a balanced paren.

assumedtype
^^^^^^^^^^^

When this attribute is applied to a ``void *`` argument, the Fortran
assumed-type declaration, ``type(*)``, will be used.  Since Fortran
defaults to pass-by-reference, the argument will be passed to C as a
``void *`` argument.  The C function will need some other mechanism to
determine the type of the argument before dereferencing the pointer.
Note that *assumed-type* is part of Fortran 2018.

capsule
^^^^^^^

Name of capsule argument.
Defaults to C_var_capsule_template.

cdesc
^^^^^

Pass argument from Fortran to C wrapper as a pointer to a context type.
This struct contains the address, type, rank and size of the argument.

.. XXX argument is named by context

charlen
^^^^^^^

*charlen* is used to define the size of a ``char *arg+intent(out)``
argument in the Python wrapper. This deals with the case where ``arg``
is provided by the user and the function writes into the provided
space.  This technique has the inherent risk of overwritting memory if
the supplied buffer is not long enough.  For example, when used in C
the user would write:

.. code-block:: c

    #define API_CHARLEN
    char buffer[API_CHARLEN];
    fill_buffer(buffer);

The Python wrapper must know the assumed length before calling the
function.  It will then be converted into a *str* object by
``PyString_FromString``.

Fortran does not use this attribute since the *buffer* argument is
supplied by the user. However, it is useful to provide the parameter
by adding a splicer block in the YAML file:

.. code-block:: yaml

    splicer_code:
      f:
        module_top:
        -  "integer, parameter :: MAXNAME = 20"

.. warning :: Using *charlen* and *dimension* together is not currently supported.

default
^^^^^^^

Default value for C++ function argument.
This value is implied by C++ default argument syntax.


deref
^^^^^

List how to dereference pointer arguments or function results.
This may be used in conjunction with *dimension* to create arrays.

allocatable

    For Fortran, add ``ALLOCATABLE`` attribute to argument.
    An ``ALLOCATE`` statement is added and the contents of the C++ argument
    is copied.  If *owner(caller)* is also defined, the C++ argument
    is released.  The caller is responsible to ``DEALLOCATE`` the array.

    For Python, create a NumPy array (same as *pointer* attribute)

pointer

    For *intent(in)* arguments, a ``POINTER`` Fortran attribute will be added.
    This allows a dynamic memory address to be passs to the library.

    .. code-block:: yaml

        void giveMemory(arg *data +intent(in)+deref(pointer))
    
    For *intent(out)* arguments this indicates that memory from the
    library is being passed back to the user and will be assigned using
    ``c_f_pointer``.

    If *owner(caller)* is also defined, an additional argument is added
    which is used to release the memory.

    For Python, create a list or NumPy array.

    .. code-block:: yaml

        - decl: double *ReturnPtrFun() +dimension(10)
        - decl: void ReturnPtrArg(double **arg +intent(out)+dimension(10))

        - decl: double *ReturnScalar() +deref(pointer)

    A *pointer* to scalar will also return a NumPy array in Python.
    Use *+deref(scalar)* to get a scalar.
          

raw

    For Fortran, return a ``type(C_PTR)``.

    For Python, return a ``PyCapsule``.

scalar

    Treat the pointee as a scalar.
    For Fortran, return a scalar and not a pointer to the scalar.
    For Python, this will not create a NumPy object.

.. XXX copy
   Fortran, copy into existing argument.
   Python, useful for *intent(inout)*.

dimension
^^^^^^^^^

A list of array extents for pointer or reference variables.
All arrays use the language's default lower-bound
(1 for Fortran and 0 for Python).
Used to define the dimension of pointer arguments with *intent(out)*
and function results.
A dimension without any value is an error -- ``+dimension``.

The expression is evaluated in a C/C++ context.

.. Sets the Fortran DIMENSION attribute.
   Pointer argument should be passed through since it is an array.
   *value* attribute must not be *True*.
   If set without a value, it defaults to ``(*)``:

.. code-block:: text

    struct {
      int len;
      double *array +dimension(len);
    };

An expression can also contain a *intent(out)* argument of the function
being wrapped.

.. code-block:: text

    int * get_array(int **count +intent(out)+hidden) +dimension(count)

Argument ``count`` will be used to define the shape of the function result
but will not be part of the wrapped API since it is *hidden*.

*rank* and *dimension* can not be specified together.

.. XXX ``+dimension(size(in))`` is similar to ``mold(in)``, but works
   better with multiple dimensions to avoid ``+dimension(size(in,1), size(in,2))


external
^^^^^^^^

This attribute is only valid with function pointers.  It will ensure
that a Fortran wrapper is created which uses the ``external``
statement for the argument.  This will allow any function to be used
as the dummy argument for the function pointer.

free_pattern
^^^^^^^^^^^^

A name in the **patterns** section which lists code to be used to 
release memory.  Used with function results.
It is used in the *C_memory_dtor_function* and will have the 
variable ``void *ptr`` available as the pointer to the memory
to be released.
See :ref:`MemoryManagementAnchor` for details.

..  and *intent(out)* arguments.


hidden
^^^^^^

The argument will not appear in the Fortran API.
But it will be passed to the C wrapper.
This allows the value to be used in the C wrapper.
For example, setting the shape of a pointer function:

.. code-block:: text

      int * ReturnIntPtr(int *len+intent(out)+hidden +dimension(len))

.. assumed intent(out)


implied
^^^^^^^
.. assumed intent(in)

The value of an arguments to the C++ function may be implied by other arguments.
If so the *implied* attribute can be used to assign the value to the argument and 
it will not be included in the wrapped API.

Used to compute value of argument to C++ based on argument
to Fortran or Python wrapper.  Useful with array sizes:

.. code-block:: text

      int Sum(const int * array, int len +implied(size(array))

Several functions will be converted to the corresponding code for
Python wrappers: ``size``, ``len`` and ``len_trim``.

intent
^^^^^^

The Fortran intent of the argument.
Valid values are ``in``, ``out``, ``inout``.

  in
    The argument will only be read from.
  inout
    The argument will be read from and written to.
  out
    The argument will be written to.

Nonpointer arguments can only be *intent(in)*.
If the argument is ``const``, the default is ``in``.

In Python, *intent(out)* arguments are not used as
input arguments to the function but are returned as values.

len
^^^

For a string argument, pass an additional argument to the
C wrapper with the result of the Fortran intrinsic ``len``.
If a value for the attribute is provided it will be the name
of the extra argument.  If no value is provided then the
argument name defaults to option *C_var_len_template*.

When used with a function, it will be the length of the return
value of the function using the declaration:

.. code-block:: text

     character(kind=C_CHAR, len={c_var_len}) :: {F_result}

len_trim
^^^^^^^^

For a string argument, pass an additional argument to the
C wrapper with the result of the Fortran intrinsic ``len_trim``.
If a value for the attribute is provided it will be the name
of the extra argument.  If no value is provided then the
argument name defaults to option *C_var_trim_template*.

.. mold - The *mold* argument is similar to the *mold* argument in the Fortran
   ``allocate`` statement, it will allocate the argument as the same shape as
   value of old   - int *out +mold(in)
   Use instead of *dimension*.
   ``PyArray_NewLikeArray``.
   

name
^^^^

Name of the method.
Useful for constructor and destructor methods which have default names
``ctor`` and ``dtor``.  Also useful when class member variables use a
convention such as ``m_variable``.  The *name* can be set to
*variable* to avoid polluting the Fortran interface with the ``m_``
prefix.  Fortran and Python both have an explicit scope of
``self%variable`` and ``self.variable`` instead of an implied
``this``.

owner
^^^^^

Specifies who is responsible to release the memory associated with the argument/result.

The terms follow Python's reference counting .  [Python_Refcount]_
The default is set by option *default_owner* which is initialized to *borrow*.

.. new   The caller is responsible to release the memory.

.. borrow  The memory belongs to the C++ library.  Do not release.

.. XXX fix terms

caller

   The memory belongs to the user who is responsible to delete it.
   A shadow class must have a destructor wrapped in order to delete 
   the memory.

library

   The memory belongs to the library and should not be deleted by
   the user.
   This is the default value.

.. steal  intent(in)

rank
^^^^

Add an assumed-shape dimension with the given rank.
*rank* must be 0-7.
A rank of 0 implies a scalar argument.

.. code-block:: yaml

    double *array +rank(2)

Creates the declaration:

.. code-block:: fortran

    real(C_DOUBLE) :: array(:,:)

Use with ``+intent(in)`` arguments when the wrapper should accept any
extent instead of using Fortran's assumed-shape with ``dimension(:)``.
    
This can be simpler than the *dimension* attribute for multidimension arrays.
*rank* and *dimension* can not be specified together.

.. XXX to be used with fortran_generic and formatting  +rank({generic_rank})


readonly
^^^^^^^^

May be added to struct or class member to avoid creating a setter function.
If the member is `const`, this attribute is added by Shroud.

value
^^^^^

If true, pass-by-value; else, pass-by-reference.
This attribute is implied when the argument is not a pointer or reference.
This will also default to ``intent(IN)`` since there is no way to return
a value.

.. note:: The Fortran wrapper may use an intrinsic function for some
          attributes. For example, *len*, *len_trim*, and *size*.
          If there is an argument with the same name, the generated
          code may not compile.

          Shroud preserves the names of the arguments since Fortran
          allows them to be used in function calls - ``call worker(len=10)``

Statements
----------

The code generated for each argument and return value can be
controlled by statement dictionaries.
Shroud has many entries built in which are used for most arguments.
But it is possible to add custom code to the wrapper by providing
additional fields.  Most wrappers will not need to provide this
information.



An example from strings.yaml:

.. code-block:: yaml

    - decl: const string * getConstStringPtrLen() +len=30
      doxygen:
        brief: return a 'const string *' as character(30)
        description: |
          It is the caller's responsibility to release the string
          created by the C++ library.
          This is accomplished with C_finalize_buf which is possible
          because +len(30) so the contents are copied before returning.
      fstatements:
        c_buf:
          final:
          - delete {cxx_var};

An example from vectors.yaml:

.. code-block:: yaml

    - decl: void vector_iota_out_with_num(std::vector<int> &arg+intent(out))
      fstatements:
        c_buf:
          return_type: long
          ret:
          - return Darg->size;
        f:
          result: num
          f_module:
            iso_c_binding: ["C_LONG"]
          declare:
          -  "integer(C_LONG) :: {F_result}"
          call:
          -  "{F_result} = {F_C_call}({F_arg_c_call})"
               

          

Patterns
--------

.. XXX still used?

To address the issue of semantic differences between Fortran and C++,
*patterns* may be used to insert additional code.  A *pattern* is a 
code template which is inserted at a specific point in the wrapper.
They are defined in the input YAML file:

.. code-block:: yaml

   declarations:
   - decl: const string& getString2+len=30()
     C_error_pattern: C_invalid_name

   patterns:
     C_invalid_name: |
         if ({cxx_var}.empty()) {{
             return NULL;
         }}

The **C_error_pattern** will insert code after the call to the C++
function in the C wrapper and before any post_call sections from the
types. The bufferified version of a function will append
``_buf`` to the **C_error_pattern** value.  The *pattern* is
formatted using the context of the return argument if present,
otherwise the context of the function is used.  This means that
*c_var* and *c_var_len* refer to the argument which is added to
contain the function result for the ``_buf`` pattern.

The function ``getString2`` is returning a ``std::string`` reference.
Since C and Fortran cannot deal with this directly, the empty string
is converted into a ``NULL`` pointer::
will blank fill the result:

.. code-block:: c++

    const char * STR_get_string2()
    {
        const std::string & SHCXX_rv = getString2();
        // C_error_pattern
        if (SHCXX_rv.empty()) {
            return NULL;
        }
        const char * SHC_rv = SHCXX_rv.c_str();
        return SHC_rv;
    }



Splicers
--------

No matter how many features are added to Shroud there will always exist
cases that it does not handle.  One of the weaknesses of generated
code is that if the generated code is edited it becomes difficult to
regenerate the code and preserve the edits.  To deal with this
situation each block of generated code is surrounded by 'splicer'
comments:

.. code-block:: c++

    const char * STR_get_char3()
    {
        // splicer begin function.get_char3
        const char * SH_rv = getChar3();
        return SH_rv;
        // splicer end function.get_char3
    }

These comments delineate a section of code which can be replaced by
the user.  The splicer's name, ``function.get_char3`` in the example,
is used to determine where to insert the code.

There are two ways to define splicers in the YAML file. First add 
a list of files which contain the splicer text:

.. code-block:: yaml

    splicer:
      f:
      -  fsplicer.f
      c:
      -  csplicer.c

In the listed file, add the begin and end splicer comments,
then add the code which should be inserted into the wrapper inbetween the comments.
Multiple splicer can be added to an input file.  Any text that is not within a
splicer block is ignored.  Splicers must be sorted by language.  If
the input file ends with ``.f`` or ``.f90`` it is processed as
splicers for the generated Fortran code.  Code for the C wrappers must
end with any of ``.c``, ``.h``, ``.cpp``, ``.hpp``, ``.cxx``,
``.hxx``, ``.cc``, ``.C``:

.. code-block:: c++

    -- Lines outside blocks are ignore
    // splicer begin function.get_char3
    const char * SH_rv = getChar3();
    SH_rv[0] = 'F';    // replace first character for Fortran
    return SH_rv + 1;
    // splicer end function.get_char3

This technique is useful when the splicers are very large or are
generated by some other process.

.. The splicer file may be added to the Shroud command line
   along with the YAML file.

The second method is to add the splicer code directly into the YAML file.
A splicer can be added after the ``decl`` line.
This splicer takes priority over other ways of defining splicers.

.. code-block:: yaml

   - decl: bool isNameValid(const std::string& name)
     splicer:
        c:
        - "return name != NULL;"
        f:
        - 'rv = name .ne. " "'

A splicer can be added in the ``splicer_code`` section.
This can be used to add code to spliers which do not correspond
directly to a declaration.
Each level of splicer is a mapping and each line of text is an array entry:

.. code-block:: yaml

    splicer_code:
      c:
        function:
          get_char3:
          - const char * SH_rv = getChar3();
          - SH_rv[0] = 'F';    // replace first character for Fortran
          - return SH_rv + 1;

In addition to replacing code for a function wrapper, there are 
splicers that are generated which allow a user to insert additional
code for helper functions or declarations:

.. code-block:: text

    ! file_top
    module {F_module_name}
       ! module_use
       implicit none
       ! module_top

       type class1
         ! class.{cxx_class}.component_part
       contains
         ! class.{cxx_class}.generic.{F_name_generic}
         ! class.{cxx_class}.type_bound_procedure_part
       end type class1

       interface
          ! additional_interfaces
       end interface

       contains

       ! function.{F_name_function}

       ! {cxx_class}.method.{F_name_function}

       ! additional_functions

    end module {F_module_name}

.. from _create_splicer

C header:

.. code-block:: c++

    // class.{class_name}.CXX_declarations

    extern "C" {
    // class.{class_name}.C_declarations
    }

C implementation:

.. code-block:: c++

    // class.{class_name}.CXX_definitions

    extern "C" {
      // class.{class_name}.C_definitions

      // function.{underscore_name}{function_suffix}

      // class.{cxx_class}.method.{underscore_name}{function_suffix}

    }

The splicer comments can be eliminated by setting the option
**show_splicer_comments** to false. This may be useful to 
eliminate the clutter of the splicer comments.





.. rubric:: Footnotes

.. [Python_Format] `<https://docs.python.org/2/library/string.html#format-string-syntax>`_

.. [Python_Refcount] `<https://docs.python.org/3/c-api/intro.html#reference-count-details>`_

.. [yaml] `yaml.org <http://yaml.org/>`_
