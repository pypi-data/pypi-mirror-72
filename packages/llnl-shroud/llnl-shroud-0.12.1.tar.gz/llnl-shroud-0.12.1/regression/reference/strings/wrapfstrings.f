! wrapfstrings.f
! This file is generated by Shroud 0.12.1. Do not edit.
! Copyright (c) 2017-2020, Lawrence Livermore National Security, LLC and
! other Shroud Project Developers.
! See the top-level COPYRIGHT file for details.
!
! SPDX-License-Identifier: (BSD-3-Clause)
!
!>
!! \file wrapfstrings.f
!! \brief Shroud generated wrapper for strings library
!<
! splicer begin file_top
! splicer end file_top
module strings_mod
    use iso_c_binding, only : C_INT, C_LONG, C_NULL_PTR, C_PTR, C_SIZE_T
    ! splicer begin module_use
    ! splicer end module_use
    implicit none

    ! splicer begin module_top
    ! splicer end module_top

    ! helper capsule_data_helper
    type, bind(C) :: SHROUD_capsule_data
        type(C_PTR) :: addr = C_NULL_PTR  ! address of C++ memory
        integer(C_INT) :: idtor = 0       ! index of destructor
    end type SHROUD_capsule_data

    ! start array_context
    ! helper array_context
    type, bind(C) :: SHROUD_array
        ! address of C++ memory
        type(SHROUD_capsule_data) :: cxx
        ! address of data in cxx
        type(C_PTR) :: base_addr = C_NULL_PTR
        ! type of element
        integer(C_INT) :: type
        ! bytes-per-item or character len of data in cxx
        integer(C_SIZE_T) :: elem_len = 0_C_SIZE_T
        ! size of data in cxx
        integer(C_SIZE_T) :: size = 0_C_SIZE_T
        ! number of dimensions
        integer(C_INT) :: rank = -1
        integer(C_LONG) :: shape(7) = 0
    end type SHROUD_array
    ! end array_context

    ! ----------------------------------------
    ! Function:  void passChar
    ! Requested: c_void_scalar_result
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char status +intent(in)+value
    ! Exact:     c_char_scalar_in
    interface
        subroutine pass_char(status) &
                bind(C, name="STR_pass_char")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), value, intent(IN) :: status
        end subroutine pass_char
    end interface

    ! ----------------------------------------
    ! Function:  void passCharForce
    ! Requested: c_void_scalar_result
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char status +intent(in)+value
    ! Exact:     c_char_scalar_in
    interface
        subroutine c_pass_char_force(status) &
                bind(C, name="STR_pass_char_force")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), value, intent(IN) :: status
        end subroutine c_pass_char_force
    end interface

    ! ----------------------------------------
    ! Function:  char returnChar
    ! Exact:     c_char_scalar_result
    interface
        function c_return_char() &
                result(SHT_rv) &
                bind(C, name="STR_return_char")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR) :: SHT_rv
        end function c_return_char
    end interface

    ! ----------------------------------------
    ! Function:  void returnChar
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char * SHF_rv +intent(out)+len(NSHF_rv)
    ! Exact:     c_char_*_result_buf
    interface
        subroutine c_return_char_bufferify(SHF_rv, NSHF_rv) &
                bind(C, name="STR_return_char_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHF_rv(*)
            integer(C_INT), value, intent(IN) :: NSHF_rv
        end subroutine c_return_char_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void passCharPtr
    ! Requested: c_void_scalar_result
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char * dest +charlen(40)+intent(out)
    ! Requested: c_char_*_out
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const char * src +intent(in)
    ! Requested: c_char_*_in
    ! Match:     c_default
    ! start c_pass_char_ptr
    interface
        subroutine c_pass_char_ptr(dest, src) &
                bind(C, name="STR_pass_char_ptr")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: dest(*)
            character(kind=C_CHAR), intent(IN) :: src(*)
        end subroutine c_pass_char_ptr
    end interface
    ! end c_pass_char_ptr

    ! ----------------------------------------
    ! Function:  void passCharPtr
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char * dest +charlen(40)+intent(out)+len(Ndest)
    ! Exact:     c_char_*_out_buf
    ! ----------------------------------------
    ! Argument:  const char * src +intent(in)
    ! Requested: c_char_*_in
    ! Match:     c_default
    ! start c_pass_char_ptr_bufferify
    interface
        subroutine c_pass_char_ptr_bufferify(dest, Ndest, src) &
                bind(C, name="STR_pass_char_ptr_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: dest(*)
            integer(C_INT), value, intent(IN) :: Ndest
            character(kind=C_CHAR), intent(IN) :: src(*)
        end subroutine c_pass_char_ptr_bufferify
    end interface
    ! end c_pass_char_ptr_bufferify

    ! ----------------------------------------
    ! Function:  void passCharPtrInOut
    ! Requested: c_void_scalar_result
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char * s +intent(inout)
    ! Requested: c_char_*_inout
    ! Match:     c_default
    interface
        subroutine c_pass_char_ptr_in_out(s) &
                bind(C, name="STR_pass_char_ptr_in_out")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: s(*)
        end subroutine c_pass_char_ptr_in_out
    end interface

    ! ----------------------------------------
    ! Function:  void passCharPtrInOut
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char * s +intent(inout)+len(Ns)+len_trim(Ls)
    ! Exact:     c_char_*_inout_buf
    interface
        subroutine c_pass_char_ptr_in_out_bufferify(s, Ls, Ns) &
                bind(C, name="STR_pass_char_ptr_in_out_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: s(*)
            integer(C_INT), value, intent(IN) :: Ls
            integer(C_INT), value, intent(IN) :: Ns
        end subroutine c_pass_char_ptr_in_out_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const char * getCharPtr1 +deref(allocatable)
    ! Exact:     c_char_*_result
    ! start c_get_char_ptr1
    interface
        function c_get_char_ptr1() &
                result(SHT_rv) &
                bind(C, name="STR_get_char_ptr1")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_char_ptr1
    end interface
    ! end c_get_char_ptr1

    ! ----------------------------------------
    ! Function:  void getCharPtr1
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const char * SHF_rv +context(DSHF_rv)+deref(allocatable)+intent(out)
    ! Exact:     c_char_*_result_buf_allocatable
    ! start c_get_char_ptr1_bufferify
    interface
        subroutine c_get_char_ptr1_bufferify(DSHF_rv) &
                bind(C, name="STR_get_char_ptr1_bufferify")
            import :: SHROUD_array
            implicit none
            type(SHROUD_array), intent(OUT) :: DSHF_rv
        end subroutine c_get_char_ptr1_bufferify
    end interface
    ! end c_get_char_ptr1_bufferify

    ! ----------------------------------------
    ! Function:  const char * getCharPtr2 +deref(result-as-arg)+len(30)
    ! Exact:     c_char_*_result
    ! start c_get_char_ptr2
    interface
        function c_get_char_ptr2() &
                result(SHT_rv) &
                bind(C, name="STR_get_char_ptr2")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_char_ptr2
    end interface
    ! end c_get_char_ptr2

    ! ----------------------------------------
    ! Function:  void getCharPtr2 +len(30)
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char * SHF_rv +intent(out)+len(NSHF_rv)
    ! Exact:     c_char_*_result_buf
    ! start c_get_char_ptr2_bufferify
    interface
        subroutine c_get_char_ptr2_bufferify(SHF_rv, NSHF_rv) &
                bind(C, name="STR_get_char_ptr2_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHF_rv(*)
            integer(C_INT), value, intent(IN) :: NSHF_rv
        end subroutine c_get_char_ptr2_bufferify
    end interface
    ! end c_get_char_ptr2_bufferify

    ! ----------------------------------------
    ! Function:  const char * getCharPtr3 +deref(result-as-arg)
    ! Exact:     c_char_*_result
    ! start c_get_char_ptr3
    interface
        function c_get_char_ptr3() &
                result(SHT_rv) &
                bind(C, name="STR_get_char_ptr3")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_char_ptr3
    end interface
    ! end c_get_char_ptr3

    ! ----------------------------------------
    ! Function:  void getCharPtr3
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char * output +intent(out)+len(Noutput)
    ! Exact:     c_char_*_result_buf
    ! start c_get_char_ptr3_bufferify
    interface
        subroutine c_get_char_ptr3_bufferify(output, Noutput) &
                bind(C, name="STR_get_char_ptr3_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: output(*)
            integer(C_INT), value, intent(IN) :: Noutput
        end subroutine c_get_char_ptr3_bufferify
    end interface
    ! end c_get_char_ptr3_bufferify

    ! ----------------------------------------
    ! Function:  const char * getCharPtr4 +deref(raw)
    ! Exact:     c_char_*_result
    interface
        function get_char_ptr4() &
                result(SHT_rv) &
                bind(C, name="STR_get_char_ptr4")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function get_char_ptr4
    end interface

    ! ----------------------------------------
    ! Function:  void getConstStringResult
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const string * SHF_rv +context(DSHF_rv)+deref(allocatable)+intent(out)
    ! Requested: c_string_*_result_buf_allocatable
    ! Match:     c_string_result_buf_allocatable
    interface
        subroutine c_get_const_string_result_bufferify(DSHF_rv) &
                bind(C, name="STR_get_const_string_result_bufferify")
            import :: SHROUD_array
            implicit none
            type(SHROUD_array), intent(OUT) :: DSHF_rv
        end subroutine c_get_const_string_result_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void getConstStringLen +len(30)
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  string * SHF_rv +intent(out)+len(NSHF_rv)
    ! Requested: c_string_*_result_buf
    ! Match:     c_string_result_buf
    interface
        subroutine c_get_const_string_len_bufferify(SHF_rv, NSHF_rv) &
                bind(C, name="STR_get_const_string_len_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHF_rv(*)
            integer(C_INT), value, intent(IN) :: NSHF_rv
        end subroutine c_get_const_string_len_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void getConstStringAsArg
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  string * output +intent(out)+len(Noutput)
    ! Requested: c_string_*_result_buf
    ! Match:     c_string_result_buf
    interface
        subroutine c_get_const_string_as_arg_bufferify(output, Noutput) &
                bind(C, name="STR_get_const_string_as_arg_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: output(*)
            integer(C_INT), value, intent(IN) :: Noutput
        end subroutine c_get_const_string_as_arg_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void getConstStringAlloc
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const std::string * SHF_rv +context(DSHF_rv)+deref(allocatable)+intent(out)
    ! Requested: c_string_*_result_buf_allocatable
    ! Match:     c_string_result_buf_allocatable
    interface
        subroutine c_get_const_string_alloc_bufferify(DSHF_rv) &
                bind(C, name="STR_get_const_string_alloc_bufferify")
            import :: SHROUD_array
            implicit none
            type(SHROUD_array), intent(OUT) :: DSHF_rv
        end subroutine c_get_const_string_alloc_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const string & getConstStringRefPure +deref(allocatable)
    ! Requested: c_string_&_result
    ! Match:     c_string_result
    ! start c_get_const_string_ref_pure
    interface
        function c_get_const_string_ref_pure() &
                result(SHT_rv) &
                bind(C, name="STR_get_const_string_ref_pure")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ref_pure
    end interface
    ! end c_get_const_string_ref_pure

    ! ----------------------------------------
    ! Function:  void getConstStringRefPure
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const string & SHF_rv +context(DSHF_rv)+deref(allocatable)+intent(out)
    ! Requested: c_string_&_result_buf_allocatable
    ! Match:     c_string_result_buf_allocatable
    ! start c_get_const_string_ref_pure_bufferify
    interface
        subroutine c_get_const_string_ref_pure_bufferify(DSHF_rv) &
                bind(C, name="STR_get_const_string_ref_pure_bufferify")
            import :: SHROUD_array
            implicit none
            type(SHROUD_array), intent(OUT) :: DSHF_rv
        end subroutine c_get_const_string_ref_pure_bufferify
    end interface
    ! end c_get_const_string_ref_pure_bufferify

    ! ----------------------------------------
    ! Function:  const string & getConstStringRefLen +deref(result-as-arg)+len(30)
    ! Requested: c_string_&_result
    ! Match:     c_string_result
    interface
        function c_get_const_string_ref_len() &
                result(SHT_rv) &
                bind(C, name="STR_get_const_string_ref_len")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ref_len
    end interface

    ! ----------------------------------------
    ! Function:  void getConstStringRefLen +len(30)
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  string & SHF_rv +intent(out)+len(NSHF_rv)
    ! Requested: c_string_&_result_buf
    ! Match:     c_string_result_buf
    interface
        subroutine c_get_const_string_ref_len_bufferify(SHF_rv, NSHF_rv) &
                bind(C, name="STR_get_const_string_ref_len_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHF_rv(*)
            integer(C_INT), value, intent(IN) :: NSHF_rv
        end subroutine c_get_const_string_ref_len_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const string & getConstStringRefAsArg +deref(result-as-arg)
    ! Requested: c_string_&_result
    ! Match:     c_string_result
    interface
        function c_get_const_string_ref_as_arg() &
                result(SHT_rv) &
                bind(C, name="STR_get_const_string_ref_as_arg")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ref_as_arg
    end interface

    ! ----------------------------------------
    ! Function:  void getConstStringRefAsArg
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  string & output +intent(out)+len(Noutput)
    ! Requested: c_string_&_result_buf
    ! Match:     c_string_result_buf
    interface
        subroutine c_get_const_string_ref_as_arg_bufferify(output, &
                Noutput) &
                bind(C, name="STR_get_const_string_ref_as_arg_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: output(*)
            integer(C_INT), value, intent(IN) :: Noutput
        end subroutine c_get_const_string_ref_as_arg_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const string & getConstStringRefLenEmpty +deref(result-as-arg)+len(30)
    ! Requested: c_string_&_result
    ! Match:     c_string_result
    interface
        function c_get_const_string_ref_len_empty() &
                result(SHT_rv) &
                bind(C, name="STR_get_const_string_ref_len_empty")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ref_len_empty
    end interface

    ! ----------------------------------------
    ! Function:  void getConstStringRefLenEmpty +len(30)
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  string & SHF_rv +intent(out)+len(NSHF_rv)
    ! Requested: c_string_&_result_buf
    ! Match:     c_string_result_buf
    interface
        subroutine c_get_const_string_ref_len_empty_bufferify(SHF_rv, &
                NSHF_rv) &
                bind(C, name="STR_get_const_string_ref_len_empty_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHF_rv(*)
            integer(C_INT), value, intent(IN) :: NSHF_rv
        end subroutine c_get_const_string_ref_len_empty_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const std::string & getConstStringRefAlloc +deref(allocatable)
    ! Requested: c_string_&_result
    ! Match:     c_string_result
    interface
        function c_get_const_string_ref_alloc() &
                result(SHT_rv) &
                bind(C, name="STR_get_const_string_ref_alloc")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ref_alloc
    end interface

    ! ----------------------------------------
    ! Function:  void getConstStringRefAlloc
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const std::string & SHF_rv +context(DSHF_rv)+deref(allocatable)+intent(out)
    ! Requested: c_string_&_result_buf_allocatable
    ! Match:     c_string_result_buf_allocatable
    interface
        subroutine c_get_const_string_ref_alloc_bufferify(DSHF_rv) &
                bind(C, name="STR_get_const_string_ref_alloc_bufferify")
            import :: SHROUD_array
            implicit none
            type(SHROUD_array), intent(OUT) :: DSHF_rv
        end subroutine c_get_const_string_ref_alloc_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const string * getConstStringPtrLen +deref(result-as-arg)+len(30)
    ! Requested: c_string_*_result
    ! Match:     c_string_result
    interface
        function c_get_const_string_ptr_len() &
                result(SHT_rv) &
                bind(C, name="STR_get_const_string_ptr_len")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ptr_len
    end interface

    ! ----------------------------------------
    ! Function:  void getConstStringPtrLen +len(30)
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  string * SHF_rv +intent(out)+len(NSHF_rv)
    ! Requested: c_string_*_result_buf
    ! Match:     c_string_result_buf
    interface
        subroutine c_get_const_string_ptr_len_bufferify(SHF_rv, NSHF_rv) &
                bind(C, name="STR_get_const_string_ptr_len_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHF_rv(*)
            integer(C_INT), value, intent(IN) :: NSHF_rv
        end subroutine c_get_const_string_ptr_len_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrAlloc +deref(allocatable)+owner(library)
    ! Requested: c_string_*_result
    ! Match:     c_string_result
    interface
        function c_get_const_string_ptr_alloc() &
                result(SHT_rv) &
                bind(C, name="STR_get_const_string_ptr_alloc")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ptr_alloc
    end interface

    ! ----------------------------------------
    ! Function:  void getConstStringPtrAlloc
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const std::string * SHF_rv +context(DSHF_rv)+deref(allocatable)+intent(out)+owner(library)
    ! Requested: c_string_*_result_buf_allocatable
    ! Match:     c_string_result_buf_allocatable
    interface
        subroutine c_get_const_string_ptr_alloc_bufferify(DSHF_rv) &
                bind(C, name="STR_get_const_string_ptr_alloc_bufferify")
            import :: SHROUD_array
            implicit none
            type(SHROUD_array), intent(OUT) :: DSHF_rv
        end subroutine c_get_const_string_ptr_alloc_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrOwnsAlloc +deref(allocatable)+owner(caller)
    ! Requested: c_string_*_result
    ! Match:     c_string_result
    interface
        function c_get_const_string_ptr_owns_alloc() &
                result(SHT_rv) &
                bind(C, name="STR_get_const_string_ptr_owns_alloc")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ptr_owns_alloc
    end interface

    ! ----------------------------------------
    ! Function:  void getConstStringPtrOwnsAlloc
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const std::string * SHF_rv +context(DSHF_rv)+deref(allocatable)+intent(out)+owner(caller)
    ! Requested: c_string_*_result_buf_allocatable
    ! Match:     c_string_result_buf_allocatable
    interface
        subroutine c_get_const_string_ptr_owns_alloc_bufferify(DSHF_rv) &
                bind(C, name="STR_get_const_string_ptr_owns_alloc_bufferify")
            import :: SHROUD_array
            implicit none
            type(SHROUD_array), intent(OUT) :: DSHF_rv
        end subroutine c_get_const_string_ptr_owns_alloc_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrOwnsAllocPattern +deref(allocatable)+free_pattern(C_string_free)+owner(caller)
    ! Requested: c_string_*_result
    ! Match:     c_string_result
    interface
        function c_get_const_string_ptr_owns_alloc_pattern() &
                result(SHT_rv) &
                bind(C, name="STR_get_const_string_ptr_owns_alloc_pattern")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ptr_owns_alloc_pattern
    end interface

    ! ----------------------------------------
    ! Function:  void getConstStringPtrOwnsAllocPattern
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const std::string * SHF_rv +context(DSHF_rv)+deref(allocatable)+free_pattern(C_string_free)+intent(out)+owner(caller)
    ! Requested: c_string_*_result_buf_allocatable
    ! Match:     c_string_result_buf_allocatable
    interface
        subroutine c_get_const_string_ptr_owns_alloc_pattern_bufferify( &
                DSHF_rv) &
                bind(C, name="STR_get_const_string_ptr_owns_alloc_pattern_bufferify")
            import :: SHROUD_array
            implicit none
            type(SHROUD_array), intent(OUT) :: DSHF_rv
        end subroutine c_get_const_string_ptr_owns_alloc_pattern_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringConstReference
    ! Requested: c_void_scalar_result
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const std::string & arg1 +intent(in)
    ! Requested: c_string_&_in
    ! Match:     c_string_in
    interface
        subroutine c_accept_string_const_reference(arg1) &
                bind(C, name="STR_accept_string_const_reference")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(IN) :: arg1(*)
        end subroutine c_accept_string_const_reference
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringConstReference
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const std::string & arg1 +intent(in)+len_trim(Larg1)
    ! Requested: c_string_&_in_buf
    ! Match:     c_string_in_buf
    interface
        subroutine c_accept_string_const_reference_bufferify(arg1, &
                Larg1) &
                bind(C, name="STR_accept_string_const_reference_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: arg1(*)
            integer(C_INT), value, intent(IN) :: Larg1
        end subroutine c_accept_string_const_reference_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringReferenceOut
    ! Requested: c_void_scalar_result
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string & arg1 +intent(out)
    ! Requested: c_string_&_out
    ! Match:     c_string_out
    interface
        subroutine c_accept_string_reference_out(arg1) &
                bind(C, name="STR_accept_string_reference_out")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: arg1(*)
        end subroutine c_accept_string_reference_out
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringReferenceOut
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string & arg1 +intent(out)+len(Narg1)
    ! Requested: c_string_&_out_buf
    ! Match:     c_string_out_buf
    interface
        subroutine c_accept_string_reference_out_bufferify(arg1, Narg1) &
                bind(C, name="STR_accept_string_reference_out_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: arg1(*)
            integer(C_INT), value, intent(IN) :: Narg1
        end subroutine c_accept_string_reference_out_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringReference
    ! Requested: c_void_scalar_result
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string & arg1 +intent(inout)
    ! Requested: c_string_&_inout
    ! Match:     c_string_inout
    ! start c_accept_string_reference
    interface
        subroutine c_accept_string_reference(arg1) &
                bind(C, name="STR_accept_string_reference")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
        end subroutine c_accept_string_reference
    end interface
    ! end c_accept_string_reference

    ! ----------------------------------------
    ! Function:  void acceptStringReference
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string & arg1 +intent(inout)+len(Narg1)+len_trim(Larg1)
    ! Requested: c_string_&_inout_buf
    ! Match:     c_string_inout_buf
    ! start c_accept_string_reference_bufferify
    interface
        subroutine c_accept_string_reference_bufferify(arg1, Larg1, &
                Narg1) &
                bind(C, name="STR_accept_string_reference_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
            integer(C_INT), value, intent(IN) :: Larg1
            integer(C_INT), value, intent(IN) :: Narg1
        end subroutine c_accept_string_reference_bufferify
    end interface
    ! end c_accept_string_reference_bufferify

    ! ----------------------------------------
    ! Function:  void acceptStringPointerConst
    ! Requested: c_void_scalar_result
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const std::string * arg1 +intent(in)
    ! Requested: c_string_*_in
    ! Match:     c_string_in
    interface
        subroutine c_accept_string_pointer_const(arg1) &
                bind(C, name="STR_accept_string_pointer_const")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(IN) :: arg1(*)
        end subroutine c_accept_string_pointer_const
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointerConst
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const std::string * arg1 +intent(in)+len_trim(Larg1)
    ! Requested: c_string_*_in_buf
    ! Match:     c_string_in_buf
    interface
        subroutine c_accept_string_pointer_const_bufferify(arg1, Larg1) &
                bind(C, name="STR_accept_string_pointer_const_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: arg1(*)
            integer(C_INT), value, intent(IN) :: Larg1
        end subroutine c_accept_string_pointer_const_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointer
    ! Requested: c_void_scalar_result
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string * arg1 +intent(inout)
    ! Requested: c_string_*_inout
    ! Match:     c_string_inout
    interface
        subroutine c_accept_string_pointer(arg1) &
                bind(C, name="STR_accept_string_pointer")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
        end subroutine c_accept_string_pointer
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointer
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string * arg1 +intent(inout)+len(Narg1)+len_trim(Larg1)
    ! Requested: c_string_*_inout_buf
    ! Match:     c_string_inout_buf
    interface
        subroutine c_accept_string_pointer_bufferify(arg1, Larg1, Narg1) &
                bind(C, name="STR_accept_string_pointer_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
            integer(C_INT), value, intent(IN) :: Larg1
            integer(C_INT), value, intent(IN) :: Narg1
        end subroutine c_accept_string_pointer_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void fetchStringPointer
    ! Requested: c_void_scalar_result
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string * arg1 +intent(out)
    ! Requested: c_string_*_out
    ! Match:     c_string_out
    interface
        subroutine c_fetch_string_pointer(arg1) &
                bind(C, name="STR_fetch_string_pointer")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: arg1(*)
        end subroutine c_fetch_string_pointer
    end interface

    ! ----------------------------------------
    ! Function:  void fetchStringPointer
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string * arg1 +intent(out)+len(Narg1)
    ! Requested: c_string_*_out_buf
    ! Match:     c_string_out_buf
    interface
        subroutine c_fetch_string_pointer_bufferify(arg1, Narg1) &
                bind(C, name="STR_fetch_string_pointer_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: arg1(*)
            integer(C_INT), value, intent(IN) :: Narg1
        end subroutine c_fetch_string_pointer_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointerLen
    ! Requested: c_void_scalar_result
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string * arg1 +intent(inout)
    ! Requested: c_string_*_inout
    ! Match:     c_string_inout
    ! ----------------------------------------
    ! Argument:  int * nlen +intent(out)
    ! Requested: c_native_*_out
    ! Match:     c_default
    interface
        subroutine c_accept_string_pointer_len(arg1, nlen) &
                bind(C, name="STR_accept_string_pointer_len")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
            integer(C_INT), intent(OUT) :: nlen
        end subroutine c_accept_string_pointer_len
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointerLen
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string * arg1 +intent(inout)+len(Narg1)+len_trim(Larg1)
    ! Requested: c_string_*_inout_buf
    ! Match:     c_string_inout_buf
    ! ----------------------------------------
    ! Argument:  int * nlen +intent(out)
    ! Requested: c_native_*_out_buf
    ! Match:     c_default
    interface
        subroutine c_accept_string_pointer_len_bufferify(arg1, Larg1, &
                Narg1, nlen) &
                bind(C, name="STR_accept_string_pointer_len_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
            integer(C_INT), value, intent(IN) :: Larg1
            integer(C_INT), value, intent(IN) :: Narg1
            integer(C_INT), intent(OUT) :: nlen
        end subroutine c_accept_string_pointer_len_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void fetchStringPointerLen
    ! Requested: c_void_scalar_result
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string * arg1 +intent(out)
    ! Requested: c_string_*_out
    ! Match:     c_string_out
    ! ----------------------------------------
    ! Argument:  int * nlen +intent(out)
    ! Requested: c_native_*_out
    ! Match:     c_default
    interface
        subroutine c_fetch_string_pointer_len(arg1, nlen) &
                bind(C, name="STR_fetch_string_pointer_len")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: arg1(*)
            integer(C_INT), intent(OUT) :: nlen
        end subroutine c_fetch_string_pointer_len
    end interface

    ! ----------------------------------------
    ! Function:  void fetchStringPointerLen
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string * arg1 +intent(out)+len(Narg1)
    ! Requested: c_string_*_out_buf
    ! Match:     c_string_out_buf
    ! ----------------------------------------
    ! Argument:  int * nlen +intent(out)
    ! Requested: c_native_*_out_buf
    ! Match:     c_default
    interface
        subroutine c_fetch_string_pointer_len_bufferify(arg1, Narg1, &
                nlen) &
                bind(C, name="STR_fetch_string_pointer_len_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: arg1(*)
            integer(C_INT), value, intent(IN) :: Narg1
            integer(C_INT), intent(OUT) :: nlen
        end subroutine c_fetch_string_pointer_len_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void explicit1
    ! Requested: c_void_scalar_result
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char * name +intent(in)+len_trim(AAlen)
    ! Requested: c_char_*_in
    ! Match:     c_default
    interface
        subroutine c_explicit1(name) &
                bind(C, name="STR_explicit1")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(IN) :: name(*)
        end subroutine c_explicit1
    end interface

    ! ----------------------------------------
    ! Function:  void explicit2
    ! Requested: c_void_scalar_result
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char * name +intent(out)+len(AAtrim)
    ! Requested: c_char_*_out
    ! Match:     c_default
    interface
        subroutine c_explicit2(name) &
                bind(C, name="STR_explicit2")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: name(*)
        end subroutine c_explicit2
    end interface

    ! ----------------------------------------
    ! Function:  void explicit2
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char * name +intent(out)+len(AAtrim)
    ! Exact:     c_char_*_out_buf
    interface
        subroutine c_explicit2_bufferify(name, AAtrim) &
                bind(C, name="STR_explicit2_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: name(*)
            integer(C_INT), value, intent(IN) :: AAtrim
        end subroutine c_explicit2_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void CpassChar
    ! Requested: c_void_scalar_result
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char status +intent(in)+value
    ! Exact:     c_char_scalar_in
    interface
        subroutine cpass_char(status) &
                bind(C, name="CpassChar")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), value, intent(IN) :: status
        end subroutine cpass_char
    end interface

    ! ----------------------------------------
    ! Function:  char CreturnChar
    ! Exact:     c_char_scalar_result
    interface
        function c_creturn_char() &
                result(SHT_rv) &
                bind(C, name="CreturnChar")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR) :: SHT_rv
        end function c_creturn_char
    end interface

    ! ----------------------------------------
    ! Function:  void CreturnChar
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char * SHF_rv +intent(out)+len(NSHF_rv)
    ! Exact:     c_char_*_result_buf
    interface
        subroutine c_creturn_char_bufferify(SHF_rv, NSHF_rv) &
                bind(C, name="STR_creturn_char_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHF_rv(*)
            integer(C_INT), value, intent(IN) :: NSHF_rv
        end subroutine c_creturn_char_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void CpassCharPtr
    ! Requested: c_void_scalar_result
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char * dest +intent(out)
    ! Requested: c_char_*_out
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const char * src +intent(in)
    ! Requested: c_char_*_in
    ! Match:     c_default
    interface
        subroutine c_cpass_char_ptr(dest, src) &
                bind(C, name="CpassCharPtr")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: dest(*)
            character(kind=C_CHAR), intent(IN) :: src(*)
        end subroutine c_cpass_char_ptr
    end interface

    ! ----------------------------------------
    ! Function:  void CpassCharPtr
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char * dest +intent(out)+len(Ndest)
    ! Exact:     c_char_*_out_buf
    ! ----------------------------------------
    ! Argument:  const char * src +intent(in)
    ! Requested: c_char_*_in
    ! Match:     c_default
    interface
        subroutine c_cpass_char_ptr_bufferify(dest, Ndest, src) &
                bind(C, name="STR_cpass_char_ptr_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: dest(*)
            integer(C_INT), value, intent(IN) :: Ndest
            character(kind=C_CHAR), intent(IN) :: src(*)
        end subroutine c_cpass_char_ptr_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void PostDeclare
    ! Requested: c_void_scalar_result
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int * count +intent(in)+rank(1)
    ! Requested: c_native_*_in
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string & name +intent(inout)
    ! Requested: c_string_&_inout
    ! Match:     c_string_inout
    interface
        subroutine c_post_declare(count, name) &
                bind(C, name="STR_post_declare")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            integer(C_INT), intent(IN) :: count(*)
            character(kind=C_CHAR), intent(INOUT) :: name(*)
        end subroutine c_post_declare
    end interface

    ! ----------------------------------------
    ! Function:  void PostDeclare
    ! Requested: c_void_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int * count +intent(in)+rank(1)
    ! Requested: c_native_*_in_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string & name +intent(inout)+len(Nname)+len_trim(Lname)
    ! Requested: c_string_&_inout_buf
    ! Match:     c_string_inout_buf
    interface
        subroutine c_post_declare_bufferify(count, name, Lname, Nname) &
                bind(C, name="STR_post_declare_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            integer(C_INT), intent(IN) :: count(*)
            character(kind=C_CHAR), intent(INOUT) :: name(*)
            integer(C_INT), value, intent(IN) :: Lname
            integer(C_INT), value, intent(IN) :: Nname
        end subroutine c_post_declare_bufferify
    end interface

    interface
        ! splicer begin additional_interfaces
        ! splicer end additional_interfaces
    end interface

    interface
        ! helper copy_string
        ! Copy the char* or std::string in context into c_var.
        subroutine SHROUD_copy_string_and_free(context, c_var, c_var_size) &
             bind(c,name="STR_ShroudCopyStringAndFree")
            use, intrinsic :: iso_c_binding, only : C_CHAR, C_SIZE_T
            import SHROUD_array
            type(SHROUD_array), intent(IN) :: context
            character(kind=C_CHAR), intent(OUT) :: c_var(*)
            integer(C_SIZE_T), value :: c_var_size
        end subroutine SHROUD_copy_string_and_free
    end interface

contains

    ! ----------------------------------------
    ! Function:  void passCharForce
    ! void passCharForce
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char status +intent(in)+value
    ! Exact:     f_char_scalar_in
    ! Exact:     c_char_scalar_in
    !>
    !! By default no Fortran wrapper is created.
    !! Force one so it can be tested.
    !<
    subroutine pass_char_force(status)
        character, value, intent(IN) :: status
        ! splicer begin function.pass_char_force
        call c_pass_char_force(status)
        ! splicer end function.pass_char_force
    end subroutine pass_char_force

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  char returnChar
    ! char returnChar
    ! Requested: f_char_scalar_result
    ! Match:     f_default
    ! Function:  void returnChar
    ! Exact:     c_char_scalar_result_buf
    ! ----------------------------------------
    ! Argument:  char * SHF_rv +intent(out)+len(NSHF_rv)
    ! Requested: f_char_*_result
    ! Match:     f_default
    ! Exact:     c_char_*_result_buf
    !>
    !! \brief return a char argument (non-pointer)
    !!
    !<
    function return_char() &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character :: SHT_rv
        ! splicer begin function.return_char
        call c_return_char_bufferify(SHT_rv, len(SHT_rv, kind=C_INT))
        ! splicer end function.return_char
    end function return_char

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void passCharPtr
    ! void passCharPtr
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char * dest +charlen(40)+intent(out)
    ! Requested: f_char_*_out
    ! Match:     f_default
    ! Argument:  char * dest +charlen(40)+intent(out)+len(Ndest)
    ! Exact:     c_char_*_out_buf
    !>
    !! \brief strcpy like behavior
    !!
    !! dest is marked intent(OUT) to override the intent(INOUT) default
    !! This avoid a copy-in on dest.
    !! In Python, src must not be over 40 characters, defined by charlen.
    !<
    ! start pass_char_ptr
    subroutine pass_char_ptr(dest, src)
        use iso_c_binding, only : C_INT, C_NULL_CHAR
        character(len=*), intent(OUT) :: dest
        character(len=*), intent(IN) :: src
        ! splicer begin function.pass_char_ptr
        call c_pass_char_ptr_bufferify(dest, len(dest, kind=C_INT), &
            trim(src)//C_NULL_CHAR)
        ! splicer end function.pass_char_ptr
    end subroutine pass_char_ptr
    ! end pass_char_ptr

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void passCharPtrInOut
    ! void passCharPtrInOut
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char * s +intent(inout)
    ! Requested: f_char_*_inout
    ! Match:     f_default
    ! Argument:  char * s +intent(inout)+len(Ns)+len_trim(Ls)
    ! Exact:     c_char_*_inout_buf
    !>
    !! \brief toupper
    !!
    !! Change a string in-place.
    !! For Python, return a new string since strings are immutable.
    !<
    subroutine pass_char_ptr_in_out(s)
        use iso_c_binding, only : C_INT
        character(len=*), intent(INOUT) :: s
        ! splicer begin function.pass_char_ptr_in_out
        call c_pass_char_ptr_in_out_bufferify(s, &
            len_trim(s, kind=C_INT), len(s, kind=C_INT))
        ! splicer end function.pass_char_ptr_in_out
    end subroutine pass_char_ptr_in_out

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const char * getCharPtr1 +deref(allocatable)
    ! const char * getCharPtr1 +deref(allocatable)
    ! Exact:     f_char_scalar_result_allocatable
    ! Function:  void getCharPtr1
    ! Exact:     c_char_scalar_result_buf
    ! ----------------------------------------
    ! Argument:  const char * SHF_rv +context(DSHF_rv)+deref(allocatable)+intent(out)
    ! Exact:     f_char_*_result_allocatable
    ! Exact:     c_char_*_result_buf_allocatable
    !>
    !! \brief return a 'const char *' as character(*)
    !!
    !<
    ! start get_char_ptr1
    function get_char_ptr1() &
            result(SHT_rv)
        type(SHROUD_array) :: DSHF_rv
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_char_ptr1
        call c_get_char_ptr1_bufferify(DSHF_rv)
        allocate(character(len=DSHF_rv%elem_len):: SHT_rv)
        call SHROUD_copy_string_and_free(DSHF_rv, SHT_rv, DSHF_rv%elem_len)
        ! splicer end function.get_char_ptr1
    end function get_char_ptr1
    ! end get_char_ptr1

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const char * getCharPtr2 +deref(result-as-arg)+len(30)
    ! const char * getCharPtr2 +deref(result-as-arg)+len(30)
    ! Requested: f_char_scalar_result_result-as-arg
    ! Match:     f_default
    ! Function:  void getCharPtr2 +len(30)
    ! Exact:     c_char_scalar_result_buf
    ! ----------------------------------------
    ! Argument:  char * SHF_rv +intent(out)+len(NSHF_rv)
    ! Requested: f_char_*_result
    ! Match:     f_default
    ! Exact:     c_char_*_result_buf
    !>
    !! \brief return 'const char *' with fixed size (len=30)
    !!
    !<
    ! start get_char_ptr2
    function get_char_ptr2() &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=30) :: SHT_rv
        ! splicer begin function.get_char_ptr2
        call c_get_char_ptr2_bufferify(SHT_rv, len(SHT_rv, kind=C_INT))
        ! splicer end function.get_char_ptr2
    end function get_char_ptr2
    ! end get_char_ptr2

    ! Generated by arg_to_buffer - arg_to_buffer
    ! ----------------------------------------
    ! Function:  void getCharPtr3
    ! void getCharPtr3
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char * output +intent(out)+len(Noutput)
    ! Requested: f_char_*_result
    ! Match:     f_default
    ! Exact:     c_char_*_result_buf
    !>
    !! \brief return a 'const char *' as argument
    !!
    !<
    ! start get_char_ptr3
    subroutine get_char_ptr3(output)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: output
        ! splicer begin function.get_char_ptr3
        call c_get_char_ptr3_bufferify(output, len(output, kind=C_INT))
        ! splicer end function.get_char_ptr3
    end subroutine get_char_ptr3
    ! end get_char_ptr3

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const string getConstStringResult +deref(allocatable)
    ! const string getConstStringResult +deref(allocatable)
    ! Requested: f_string_scalar_result_allocatable
    ! Match:     f_string_result_allocatable
    ! Function:  void getConstStringResult
    ! Exact:     c_string_scalar_result_buf
    ! ----------------------------------------
    ! Argument:  const string * SHF_rv +context(DSHF_rv)+deref(allocatable)+intent(out)
    ! Requested: f_string_*_result_allocatable
    ! Match:     f_string_result_allocatable
    ! Requested: c_string_*_result_buf_allocatable
    ! Match:     c_string_result_buf_allocatable
    !>
    !! \brief return an ALLOCATABLE CHARACTER from std::string
    !!
    !<
    function get_const_string_result() &
            result(SHT_rv)
        type(SHROUD_array) :: DSHF_rv
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_result
        call c_get_const_string_result_bufferify(DSHF_rv)
        allocate(character(len=DSHF_rv%elem_len):: SHT_rv)
        call SHROUD_copy_string_and_free(DSHF_rv, SHT_rv, DSHF_rv%elem_len)
        ! splicer end function.get_const_string_result
    end function get_const_string_result

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const string getConstStringLen +deref(result-as-arg)+len(30)
    ! const string getConstStringLen +deref(result-as-arg)+len(30)
    ! Requested: f_string_scalar_result_result-as-arg
    ! Match:     f_default
    ! Function:  void getConstStringLen +len(30)
    ! Exact:     c_string_scalar_result_buf
    ! ----------------------------------------
    ! Argument:  string * SHF_rv +intent(out)+len(NSHF_rv)
    ! Requested: f_string_*_result
    ! Match:     f_default
    ! Requested: c_string_*_result_buf
    ! Match:     c_string_result_buf
    !>
    !! \brief return a 'const string' as argument
    !!
    !<
    function get_const_string_len() &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=30) :: SHT_rv
        ! splicer begin function.get_const_string_len
        call c_get_const_string_len_bufferify(SHT_rv, &
            len(SHT_rv, kind=C_INT))
        ! splicer end function.get_const_string_len
    end function get_const_string_len

    ! Generated by arg_to_buffer - arg_to_buffer
    ! ----------------------------------------
    ! Function:  void getConstStringAsArg
    ! void getConstStringAsArg
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  string * output +intent(out)+len(Noutput)
    ! Requested: f_string_*_result
    ! Match:     f_default
    ! Requested: c_string_*_result_buf
    ! Match:     c_string_result_buf
    !>
    !! \brief return a 'const string' as argument
    !!
    !<
    subroutine get_const_string_as_arg(output)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: output
        ! splicer begin function.get_const_string_as_arg
        call c_get_const_string_as_arg_bufferify(output, &
            len(output, kind=C_INT))
        ! splicer end function.get_const_string_as_arg
    end subroutine get_const_string_as_arg

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const std::string getConstStringAlloc +deref(allocatable)
    ! const std::string getConstStringAlloc +deref(allocatable)
    ! Requested: f_string_scalar_result_allocatable
    ! Match:     f_string_result_allocatable
    ! Function:  void getConstStringAlloc
    ! Exact:     c_string_scalar_result_buf
    ! ----------------------------------------
    ! Argument:  const std::string * SHF_rv +context(DSHF_rv)+deref(allocatable)+intent(out)
    ! Requested: f_string_*_result_allocatable
    ! Match:     f_string_result_allocatable
    ! Requested: c_string_*_result_buf_allocatable
    ! Match:     c_string_result_buf_allocatable
    function get_const_string_alloc() &
            result(SHT_rv)
        type(SHROUD_array) :: DSHF_rv
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_alloc
        call c_get_const_string_alloc_bufferify(DSHF_rv)
        allocate(character(len=DSHF_rv%elem_len):: SHT_rv)
        call SHROUD_copy_string_and_free(DSHF_rv, SHT_rv, DSHF_rv%elem_len)
        ! splicer end function.get_const_string_alloc
    end function get_const_string_alloc

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const string & getConstStringRefPure +deref(allocatable)
    ! const string & getConstStringRefPure +deref(allocatable)
    ! Requested: f_string_scalar_result_allocatable
    ! Match:     f_string_result_allocatable
    ! Function:  void getConstStringRefPure
    ! Exact:     c_string_scalar_result_buf
    ! ----------------------------------------
    ! Argument:  const string & SHF_rv +context(DSHF_rv)+deref(allocatable)+intent(out)
    ! Requested: f_string_&_result_allocatable
    ! Match:     f_string_result_allocatable
    ! Requested: c_string_&_result_buf_allocatable
    ! Match:     c_string_result_buf_allocatable
    !>
    !! \brief return a 'const string&' as ALLOCATABLE character
    !!
    !<
    ! start get_const_string_ref_pure
    function get_const_string_ref_pure() &
            result(SHT_rv)
        type(SHROUD_array) :: DSHF_rv
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_ref_pure
        call c_get_const_string_ref_pure_bufferify(DSHF_rv)
        allocate(character(len=DSHF_rv%elem_len):: SHT_rv)
        call SHROUD_copy_string_and_free(DSHF_rv, SHT_rv, DSHF_rv%elem_len)
        ! splicer end function.get_const_string_ref_pure
    end function get_const_string_ref_pure
    ! end get_const_string_ref_pure

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const string & getConstStringRefLen +deref(result-as-arg)+len(30)
    ! const string & getConstStringRefLen +deref(result-as-arg)+len(30)
    ! Requested: f_string_scalar_result_result-as-arg
    ! Match:     f_default
    ! Function:  void getConstStringRefLen +len(30)
    ! Exact:     c_string_scalar_result_buf
    ! ----------------------------------------
    ! Argument:  string & SHF_rv +intent(out)+len(NSHF_rv)
    ! Requested: f_string_&_result
    ! Match:     f_default
    ! Requested: c_string_&_result_buf
    ! Match:     c_string_result_buf
    !>
    !! \brief return 'const string&' with fixed size (len=30)
    !!
    !! Since +len(30) is provided, the result of the function
    !! will be copied directly into memory provided by Fortran.
    !! The function will not be ALLOCATABLE.
    !<
    function get_const_string_ref_len() &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=30) :: SHT_rv
        ! splicer begin function.get_const_string_ref_len
        call c_get_const_string_ref_len_bufferify(SHT_rv, &
            len(SHT_rv, kind=C_INT))
        ! splicer end function.get_const_string_ref_len
    end function get_const_string_ref_len

    ! Generated by arg_to_buffer - arg_to_buffer
    ! ----------------------------------------
    ! Function:  void getConstStringRefAsArg
    ! void getConstStringRefAsArg
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  string & output +intent(out)+len(Noutput)
    ! Requested: f_string_&_result
    ! Match:     f_default
    ! Requested: c_string_&_result_buf
    ! Match:     c_string_result_buf
    !>
    !! \brief return a 'const string&' as argument
    !!
    !! Pass an additional argument which wil be used as the return value.
    !! The length of the output variable is declared by the caller.
    !<
    subroutine get_const_string_ref_as_arg(output)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: output
        ! splicer begin function.get_const_string_ref_as_arg
        call c_get_const_string_ref_as_arg_bufferify(output, &
            len(output, kind=C_INT))
        ! splicer end function.get_const_string_ref_as_arg
    end subroutine get_const_string_ref_as_arg

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const string & getConstStringRefLenEmpty +deref(result-as-arg)+len(30)
    ! const string & getConstStringRefLenEmpty +deref(result-as-arg)+len(30)
    ! Requested: f_string_scalar_result_result-as-arg
    ! Match:     f_default
    ! Function:  void getConstStringRefLenEmpty +len(30)
    ! Exact:     c_string_scalar_result_buf
    ! ----------------------------------------
    ! Argument:  string & SHF_rv +intent(out)+len(NSHF_rv)
    ! Requested: f_string_&_result
    ! Match:     f_default
    ! Requested: c_string_&_result_buf
    ! Match:     c_string_result_buf
    !>
    !! \brief Test returning empty string reference
    !!
    !<
    function get_const_string_ref_len_empty() &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=30) :: SHT_rv
        ! splicer begin function.get_const_string_ref_len_empty
        call c_get_const_string_ref_len_empty_bufferify(SHT_rv, &
            len(SHT_rv, kind=C_INT))
        ! splicer end function.get_const_string_ref_len_empty
    end function get_const_string_ref_len_empty

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const std::string & getConstStringRefAlloc +deref(allocatable)
    ! const std::string & getConstStringRefAlloc +deref(allocatable)
    ! Requested: f_string_scalar_result_allocatable
    ! Match:     f_string_result_allocatable
    ! Function:  void getConstStringRefAlloc
    ! Exact:     c_string_scalar_result_buf
    ! ----------------------------------------
    ! Argument:  const std::string & SHF_rv +context(DSHF_rv)+deref(allocatable)+intent(out)
    ! Requested: f_string_&_result_allocatable
    ! Match:     f_string_result_allocatable
    ! Requested: c_string_&_result_buf_allocatable
    ! Match:     c_string_result_buf_allocatable
    function get_const_string_ref_alloc() &
            result(SHT_rv)
        type(SHROUD_array) :: DSHF_rv
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_ref_alloc
        call c_get_const_string_ref_alloc_bufferify(DSHF_rv)
        allocate(character(len=DSHF_rv%elem_len):: SHT_rv)
        call SHROUD_copy_string_and_free(DSHF_rv, SHT_rv, DSHF_rv%elem_len)
        ! splicer end function.get_const_string_ref_alloc
    end function get_const_string_ref_alloc

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const string * getConstStringPtrLen +deref(result-as-arg)+len(30)
    ! const string * getConstStringPtrLen +deref(result-as-arg)+len(30)
    ! Requested: f_string_scalar_result_result-as-arg
    ! Match:     f_default
    ! Function:  void getConstStringPtrLen +len(30)
    ! Exact:     c_string_scalar_result_buf
    ! ----------------------------------------
    ! Argument:  string * SHF_rv +intent(out)+len(NSHF_rv)
    ! Requested: f_string_*_result
    ! Match:     f_default
    ! Requested: c_string_*_result_buf
    ! Match:     c_string_result_buf
    !>
    !! \brief return a 'const string *' as character(30)
    !!
    !! It is the caller's responsibility to release the string
    !! created by the C++ library.
    !! This is accomplished with C_finalize_buf which is possible
    !! because +len(30) so the contents are copied before returning.
    !<
    function get_const_string_ptr_len() &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=30) :: SHT_rv
        ! splicer begin function.get_const_string_ptr_len
        call c_get_const_string_ptr_len_bufferify(SHT_rv, &
            len(SHT_rv, kind=C_INT))
        ! splicer end function.get_const_string_ptr_len
    end function get_const_string_ptr_len

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrAlloc +deref(allocatable)+owner(library)
    ! const std::string * getConstStringPtrAlloc +deref(allocatable)+owner(library)
    ! Requested: f_string_scalar_result_allocatable_library
    ! Match:     f_string_result_allocatable
    ! Function:  void getConstStringPtrAlloc
    ! Exact:     c_string_scalar_result_buf
    ! ----------------------------------------
    ! Argument:  const std::string * SHF_rv +context(DSHF_rv)+deref(allocatable)+intent(out)+owner(library)
    ! Requested: f_string_*_result_allocatable
    ! Match:     f_string_result_allocatable
    ! Requested: c_string_*_result_buf_allocatable
    ! Match:     c_string_result_buf_allocatable
    function get_const_string_ptr_alloc() &
            result(SHT_rv)
        type(SHROUD_array) :: DSHF_rv
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_ptr_alloc
        call c_get_const_string_ptr_alloc_bufferify(DSHF_rv)
        allocate(character(len=DSHF_rv%elem_len):: SHT_rv)
        call SHROUD_copy_string_and_free(DSHF_rv, SHT_rv, DSHF_rv%elem_len)
        ! splicer end function.get_const_string_ptr_alloc
    end function get_const_string_ptr_alloc

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrOwnsAlloc +deref(allocatable)+owner(caller)
    ! const std::string * getConstStringPtrOwnsAlloc +deref(allocatable)+owner(caller)
    ! Requested: f_string_scalar_result_allocatable_caller
    ! Match:     f_string_result_allocatable
    ! Function:  void getConstStringPtrOwnsAlloc
    ! Exact:     c_string_scalar_result_buf
    ! ----------------------------------------
    ! Argument:  const std::string * SHF_rv +context(DSHF_rv)+deref(allocatable)+intent(out)+owner(caller)
    ! Requested: f_string_*_result_allocatable
    ! Match:     f_string_result_allocatable
    ! Requested: c_string_*_result_buf_allocatable
    ! Match:     c_string_result_buf_allocatable
    !>
    !! It is the caller's responsibility to release the string
    !! created by the C++ library.
    !! This is accomplished +owner(caller) which sets idtor.
    !! The contents are copied by Fortran so they must outlast
    !! the return from the C wrapper.
    !<
    function get_const_string_ptr_owns_alloc() &
            result(SHT_rv)
        type(SHROUD_array) :: DSHF_rv
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_ptr_owns_alloc
        call c_get_const_string_ptr_owns_alloc_bufferify(DSHF_rv)
        allocate(character(len=DSHF_rv%elem_len):: SHT_rv)
        call SHROUD_copy_string_and_free(DSHF_rv, SHT_rv, DSHF_rv%elem_len)
        ! splicer end function.get_const_string_ptr_owns_alloc
    end function get_const_string_ptr_owns_alloc

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrOwnsAllocPattern +deref(allocatable)+free_pattern(C_string_free)+owner(caller)
    ! const std::string * getConstStringPtrOwnsAllocPattern +deref(allocatable)+free_pattern(C_string_free)+owner(caller)
    ! Requested: f_string_scalar_result_allocatable_caller
    ! Match:     f_string_result_allocatable
    ! Function:  void getConstStringPtrOwnsAllocPattern
    ! Exact:     c_string_scalar_result_buf
    ! ----------------------------------------
    ! Argument:  const std::string * SHF_rv +context(DSHF_rv)+deref(allocatable)+free_pattern(C_string_free)+intent(out)+owner(caller)
    ! Requested: f_string_*_result_allocatable
    ! Match:     f_string_result_allocatable
    ! Requested: c_string_*_result_buf_allocatable
    ! Match:     c_string_result_buf_allocatable
    !>
    !! Similar to getConstStringPtrOwnsAlloc, but uses pattern to release memory.
    !<
    function get_const_string_ptr_owns_alloc_pattern() &
            result(SHT_rv)
        type(SHROUD_array) :: DSHF_rv
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_ptr_owns_alloc_pattern
        call c_get_const_string_ptr_owns_alloc_pattern_bufferify(DSHF_rv)
        allocate(character(len=DSHF_rv%elem_len):: SHT_rv)
        call SHROUD_copy_string_and_free(DSHF_rv, SHT_rv, DSHF_rv%elem_len)
        ! splicer end function.get_const_string_ptr_owns_alloc_pattern
    end function get_const_string_ptr_owns_alloc_pattern

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void acceptStringConstReference
    ! void acceptStringConstReference
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const std::string & arg1 +intent(in)
    ! Requested: f_string_&_in
    ! Match:     f_default
    ! Argument:  const std::string & arg1 +intent(in)+len_trim(Larg1)
    ! Requested: c_string_&_in_buf
    ! Match:     c_string_in_buf
    !>
    !! \brief Accept a const string reference
    !!
    !! Save contents of arg1.
    !! arg1 is assumed to be intent(IN) since it is const
    !! Will copy in.
    !<
    subroutine accept_string_const_reference(arg1)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: arg1
        ! splicer begin function.accept_string_const_reference
        call c_accept_string_const_reference_bufferify(arg1, &
            len_trim(arg1, kind=C_INT))
        ! splicer end function.accept_string_const_reference
    end subroutine accept_string_const_reference

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void acceptStringReferenceOut
    ! void acceptStringReferenceOut
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string & arg1 +intent(out)
    ! Requested: f_string_&_out
    ! Match:     f_default
    ! Argument:  std::string & arg1 +intent(out)+len(Narg1)
    ! Requested: c_string_&_out_buf
    ! Match:     c_string_out_buf
    !>
    !! \brief Accept a string reference
    !!
    !! Set out to a constant string.
    !! arg1 is intent(OUT)
    !! Must copy out.
    !<
    subroutine accept_string_reference_out(arg1)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: arg1
        ! splicer begin function.accept_string_reference_out
        call c_accept_string_reference_out_bufferify(arg1, &
            len(arg1, kind=C_INT))
        ! splicer end function.accept_string_reference_out
    end subroutine accept_string_reference_out

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void acceptStringReference
    ! void acceptStringReference
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string & arg1 +intent(inout)
    ! Requested: f_string_&_inout
    ! Match:     f_default
    ! Argument:  std::string & arg1 +intent(inout)+len(Narg1)+len_trim(Larg1)
    ! Requested: c_string_&_inout_buf
    ! Match:     c_string_inout_buf
    !>
    !! \brief Accept a string reference
    !!
    !! Append "dog" to the end of arg1.
    !! arg1 is assumed to be intent(INOUT)
    !! Must copy in and copy out.
    !<
    ! start accept_string_reference
    subroutine accept_string_reference(arg1)
        use iso_c_binding, only : C_INT
        character(len=*), intent(INOUT) :: arg1
        ! splicer begin function.accept_string_reference
        call c_accept_string_reference_bufferify(arg1, &
            len_trim(arg1, kind=C_INT), len(arg1, kind=C_INT))
        ! splicer end function.accept_string_reference
    end subroutine accept_string_reference
    ! end accept_string_reference

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void acceptStringPointerConst
    ! void acceptStringPointerConst
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const std::string * arg1 +intent(in)
    ! Requested: f_string_*_in
    ! Match:     f_default
    ! Argument:  const std::string * arg1 +intent(in)+len_trim(Larg1)
    ! Requested: c_string_*_in_buf
    ! Match:     c_string_in_buf
    !>
    !! \brief Accept a const string pointer - intent(in)
    !!
    !<
    subroutine accept_string_pointer_const(arg1)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: arg1
        ! splicer begin function.accept_string_pointer_const
        call c_accept_string_pointer_const_bufferify(arg1, &
            len_trim(arg1, kind=C_INT))
        ! splicer end function.accept_string_pointer_const
    end subroutine accept_string_pointer_const

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void acceptStringPointer
    ! void acceptStringPointer
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string * arg1 +intent(inout)
    ! Requested: f_string_*_inout
    ! Match:     f_default
    ! Argument:  std::string * arg1 +intent(inout)+len(Narg1)+len_trim(Larg1)
    ! Requested: c_string_*_inout_buf
    ! Match:     c_string_inout_buf
    !>
    !! \brief Accept a string pointer - intent(inout)
    !!
    !<
    subroutine accept_string_pointer(arg1)
        use iso_c_binding, only : C_INT
        character(len=*), intent(INOUT) :: arg1
        ! splicer begin function.accept_string_pointer
        call c_accept_string_pointer_bufferify(arg1, &
            len_trim(arg1, kind=C_INT), len(arg1, kind=C_INT))
        ! splicer end function.accept_string_pointer
    end subroutine accept_string_pointer

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void fetchStringPointer
    ! void fetchStringPointer
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string * arg1 +intent(out)
    ! Requested: f_string_*_out
    ! Match:     f_default
    ! Argument:  std::string * arg1 +intent(out)+len(Narg1)
    ! Requested: c_string_*_out_buf
    ! Match:     c_string_out_buf
    !>
    !! \brief Accept a string pointer - intent(out)
    !!
    !! Return global_str.
    !<
    subroutine fetch_string_pointer(arg1)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: arg1
        ! splicer begin function.fetch_string_pointer
        call c_fetch_string_pointer_bufferify(arg1, &
            len(arg1, kind=C_INT))
        ! splicer end function.fetch_string_pointer
    end subroutine fetch_string_pointer

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void acceptStringPointerLen
    ! void acceptStringPointerLen
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string * arg1 +intent(inout)
    ! Requested: f_string_*_inout
    ! Match:     f_default
    ! Argument:  std::string * arg1 +intent(inout)+len(Narg1)+len_trim(Larg1)
    ! Requested: c_string_*_inout_buf
    ! Match:     c_string_inout_buf
    ! ----------------------------------------
    ! Argument:  int * nlen +intent(out)
    ! Requested: f_native_*_out
    ! Match:     f_default
    ! Requested: c_native_*_out_buf
    ! Match:     c_default
    !>
    !! \brief Accept a string pointer - intent(inout)
    !!
    !! Test return tuple with two arguments.
    !! Must rename argument to nlen to avoid conflict with intrinsic len.
    !<
    subroutine accept_string_pointer_len(arg1, nlen)
        use iso_c_binding, only : C_INT
        character(len=*), intent(INOUT) :: arg1
        integer(C_INT), intent(OUT) :: nlen
        ! splicer begin function.accept_string_pointer_len
        call c_accept_string_pointer_len_bufferify(arg1, &
            len_trim(arg1, kind=C_INT), len(arg1, kind=C_INT), nlen)
        ! splicer end function.accept_string_pointer_len
    end subroutine accept_string_pointer_len

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void fetchStringPointerLen
    ! void fetchStringPointerLen
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string * arg1 +intent(out)
    ! Requested: f_string_*_out
    ! Match:     f_default
    ! Argument:  std::string * arg1 +intent(out)+len(Narg1)
    ! Requested: c_string_*_out_buf
    ! Match:     c_string_out_buf
    ! ----------------------------------------
    ! Argument:  int * nlen +intent(out)
    ! Requested: f_native_*_out
    ! Match:     f_default
    ! Requested: c_native_*_out_buf
    ! Match:     c_default
    !>
    !! \brief Accept a string pointer - intent(out)
    !!
    !! Return global_str.
    !! Test return tuple with two arguments.
    !! Must rename argument to nlen to avoid conflict with intrinsic len.
    !<
    subroutine fetch_string_pointer_len(arg1, nlen)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: arg1
        integer(C_INT), intent(OUT) :: nlen
        ! splicer begin function.fetch_string_pointer_len
        call c_fetch_string_pointer_len_bufferify(arg1, &
            len(arg1, kind=C_INT), nlen)
        ! splicer end function.fetch_string_pointer_len
    end subroutine fetch_string_pointer_len

    ! ----------------------------------------
    ! Function:  void explicit1
    ! void explicit1
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    subroutine explicit1(name)
        use iso_c_binding, only : C_NULL_CHAR
        character(len=*), intent(IN) :: name
        ! splicer begin function.explicit1
        call c_explicit1(trim(name)//C_NULL_CHAR)
        ! splicer end function.explicit1
    end subroutine explicit1

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void explicit2
    ! void explicit2
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char * name +intent(out)+len(AAtrim)
    ! Requested: f_char_*_out
    ! Match:     f_default
    ! Exact:     c_char_*_out_buf
    subroutine explicit2(name)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: name
        ! splicer begin function.explicit2
        call c_explicit2_bufferify(name, len(name, kind=C_INT))
        ! splicer end function.explicit2
    end subroutine explicit2

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  char CreturnChar
    ! char CreturnChar
    ! Requested: f_char_scalar_result
    ! Match:     f_default
    ! Function:  void CreturnChar
    ! Exact:     c_char_scalar_result_buf
    ! ----------------------------------------
    ! Argument:  char * SHF_rv +intent(out)+len(NSHF_rv)
    ! Requested: f_char_*_result
    ! Match:     f_default
    ! Exact:     c_char_*_result_buf
    !>
    !! \brief return a char argument (non-pointer), extern "C"
    !!
    !<
    function creturn_char() &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character :: SHT_rv
        ! splicer begin function.creturn_char
        call c_creturn_char_bufferify(SHT_rv, len(SHT_rv, kind=C_INT))
        ! splicer end function.creturn_char
    end function creturn_char

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void CpassCharPtr
    ! void CpassCharPtr
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char * dest +intent(out)
    ! Requested: f_char_*_out
    ! Match:     f_default
    ! Argument:  char * dest +intent(out)+len(Ndest)
    ! Exact:     c_char_*_out_buf
    !>
    !! \brief strcpy like behavior
    !!
    !! dest is marked intent(OUT) to override the intent(INOUT) default
    !! This avoid a copy-in on dest.
    !! extern "C"
    !<
    subroutine cpass_char_ptr(dest, src)
        use iso_c_binding, only : C_INT, C_NULL_CHAR
        character(len=*), intent(OUT) :: dest
        character(len=*), intent(IN) :: src
        ! splicer begin function.cpass_char_ptr
        call c_cpass_char_ptr_bufferify(dest, len(dest, kind=C_INT), &
            trim(src)//C_NULL_CHAR)
        ! splicer end function.cpass_char_ptr
    end subroutine cpass_char_ptr

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void PostDeclare
    ! void PostDeclare
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int * count +intent(in)+rank(1)
    ! Requested: f_native_*_in
    ! Match:     f_default
    ! Requested: c_native_*_in_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string & name +intent(inout)
    ! Requested: f_string_&_inout
    ! Match:     f_default
    ! Argument:  std::string & name +intent(inout)+len(Nname)+len_trim(Lname)
    ! Requested: c_string_&_inout_buf
    ! Match:     c_string_inout_buf
    subroutine post_declare(count, name)
        use iso_c_binding, only : C_INT
        integer(C_INT), intent(IN) :: count(:)
        character(len=*), intent(INOUT) :: name
        ! splicer begin function.post_declare
        call c_post_declare_bufferify(count, name, &
            len_trim(name, kind=C_INT), len(name, kind=C_INT))
        ! splicer end function.post_declare
    end subroutine post_declare

    ! splicer begin additional_functions
    ! splicer end additional_functions

end module strings_mod
