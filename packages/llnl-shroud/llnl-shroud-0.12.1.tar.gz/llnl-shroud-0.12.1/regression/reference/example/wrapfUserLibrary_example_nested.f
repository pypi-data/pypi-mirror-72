! wrapfUserLibrary_example_nested.f
! This file is generated by Shroud 0.12.1. Do not edit.
! Copyright (c) 2017-2020, Lawrence Livermore National Security, LLC and
! other Shroud Project Developers.
! See the top-level COPYRIGHT file for details.
!
! SPDX-License-Identifier: (BSD-3-Clause)
!
!>
!! \file wrapfUserLibrary_example_nested.f
!! \brief Shroud generated wrapper for nested namespace
!<
! splicer begin namespace.example::nested.file_top
! splicer end namespace.example::nested.file_top
module userlibrary_example_nested_mod
    use iso_c_binding, only : C_INT, C_LONG, C_NULL_PTR, C_PTR, C_SIZE_T
    ! splicer begin namespace.example::nested.module_use
    ! splicer end namespace.example::nested.module_use
    implicit none

    ! splicer begin namespace.example::nested.module_top
    top of module namespace example splicer  3
    ! splicer end namespace.example::nested.module_top

    ! helper capsule_data_helper
    type, bind(C) :: SHROUD_capsule_data
        type(C_PTR) :: addr = C_NULL_PTR  ! address of C++ memory
        integer(C_INT) :: idtor = 0       ! index of destructor
    end type SHROUD_capsule_data

    ! helper array_context
    type, bind(C) :: SHROUD_array
        ! address of C++ memory
        type(SHROUD_capsule_data) :: cxx
        ! address of data in cxx
        type(C_PTR) :: base_addr = C_NULL_PTR
        ! type of element
        integer(C_INT) :: type
        ! bytes-per-item or character len of data in cxx
        integer(C_SIZE_T) :: elem_len = 0_C_SIZE_T
        ! size of data in cxx
        integer(C_SIZE_T) :: size = 0_C_SIZE_T
        ! number of dimensions
        integer(C_INT) :: rank = -1
        integer(C_LONG) :: shape(7) = 0
    end type SHROUD_array

    type, bind(C) :: SHROUD_exclass1_capsule
        type(C_PTR) :: addr = C_NULL_PTR  ! address of C++ memory
        integer(C_INT) :: idtor = 0       ! index of destructor
    end type SHROUD_exclass1_capsule

    type exclass1
        type(SHROUD_exclass1_capsule) :: cxxmem
        ! splicer begin namespace.example::nested.class.ExClass1.component_part
          component part 1a
          component part 1b
        ! splicer end namespace.example::nested.class.ExClass1.component_part
    contains
        procedure :: delete => exclass1_dtor
        procedure :: increment_count => exclass1_increment_count
        procedure :: get_name_error_check => exclass1_get_name_error_check
        procedure :: get_name_arg => exclass1_get_name_arg
        procedure :: get_value_from_int => exclass1_get_value_from_int
        procedure :: get_value_1 => exclass1_get_value_1
        procedure :: has_addr => exclass1_has_addr
        procedure :: splicer_special => exclass1_splicer_special
        procedure :: yadda => exclass1_yadda
        procedure :: associated => exclass1_associated
        generic :: get_value => get_value_from_int, get_value_1
        ! splicer begin namespace.example::nested.class.ExClass1.type_bound_procedure_part
          type bound procedure part 1
        ! splicer end namespace.example::nested.class.ExClass1.type_bound_procedure_part
    end type exclass1

    type, bind(C) :: SHROUD_exclass2_capsule
        type(C_PTR) :: addr = C_NULL_PTR  ! address of C++ memory
        integer(C_INT) :: idtor = 0       ! index of destructor
    end type SHROUD_exclass2_capsule

    type exclass2
        type(SHROUD_exclass2_capsule) :: cxxmem
        ! splicer begin namespace.example::nested.class.ExClass2.component_part
        ! splicer end namespace.example::nested.class.ExClass2.component_part
    contains
        procedure :: delete => exclass2_dtor
        procedure :: get_name => exclass2_get_name
        procedure :: get_name2 => exclass2_get_name2
        procedure :: get_name3 => exclass2_get_name3
        procedure :: get_name4 => exclass2_get_name4
        procedure :: get_name_length => exclass2_get_name_length
        procedure :: get_class1 => exclass2_get_class1
        procedure :: declare_0_int => exclass2_declare_0_int
        procedure :: declare_0_long => exclass2_declare_0_long
        procedure :: declare_1_int => exclass2_declare_1_int
        procedure :: declare_1_long => exclass2_declare_1_long
        procedure :: destroyall => exclass2_destroyall
        procedure :: get_type_id => exclass2_get_type_id
        procedure :: set_value_int => exclass2_set_value_int
        procedure :: set_value_long => exclass2_set_value_long
        procedure :: set_value_float => exclass2_set_value_float
        procedure :: set_value_double => exclass2_set_value_double
        procedure :: get_value_int => exclass2_get_value_int
        procedure :: get_value_double => exclass2_get_value_double
        procedure :: yadda => exclass2_yadda
        procedure :: associated => exclass2_associated
        generic :: declare => declare_0_int, declare_0_long,  &
            declare_1_int, declare_1_long
        generic :: set_value => set_value_int, set_value_long,  &
            set_value_float, set_value_double
        ! splicer begin namespace.example::nested.class.ExClass2.type_bound_procedure_part
        ! splicer end namespace.example::nested.class.ExClass2.type_bound_procedure_part
    end type exclass2

    interface operator (.eq.)
        module procedure exclass1_eq
        module procedure exclass2_eq
    end interface

    interface operator (.ne.)
        module procedure exclass1_ne
        module procedure exclass2_ne
    end interface

    abstract interface

        function custom_funptr(XX0arg, XX1arg) bind(C)
            use iso_c_binding, only : C_DOUBLE, C_INT
            implicit none
            real(C_DOUBLE), value :: XX0arg
            integer(C_INT), value :: XX1arg
            type(C_PTR) :: custom_funptr
        end function custom_funptr

        subroutine func_ptr1_get() bind(C)
            implicit none
        end subroutine func_ptr1_get

        function func_ptr2_get() bind(C)
            implicit none
            type(C_PTR) :: func_ptr2_get
        end function func_ptr2_get

        function func_ptr3_get(i, arg1) bind(C)
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT), value :: i
            integer(C_INT), value :: arg1
            type(C_PTR) :: func_ptr3_get
        end function func_ptr3_get

        subroutine func_ptr5_get(verylongname1, verylongname2, &
            verylongname3, verylongname4, verylongname5, verylongname6, &
            verylongname7, verylongname8, verylongname9, &
            verylongname10) bind(C)
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT), value :: verylongname1
            integer(C_INT), value :: verylongname2
            integer(C_INT), value :: verylongname3
            integer(C_INT), value :: verylongname4
            integer(C_INT), value :: verylongname5
            integer(C_INT), value :: verylongname6
            integer(C_INT), value :: verylongname7
            integer(C_INT), value :: verylongname8
            integer(C_INT), value :: verylongname9
            integer(C_INT), value :: verylongname10
        end subroutine func_ptr5_get

    end interface

    interface

        ! ----------------------------------------
        ! Function:  ExClass1
        ! Exact:     c_shadow_scalar_result
        function c_exclass1_ctor_0(SHT_crv) &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_ExClass1_ctor_0")
            use iso_c_binding, only : C_PTR
            import :: SHROUD_exclass1_capsule
            implicit none
            type(SHROUD_exclass1_capsule), intent(OUT) :: SHT_crv
            type(C_PTR) SHT_rv
        end function c_exclass1_ctor_0

        ! ----------------------------------------
        ! Function:  ExClass1
        ! Exact:     c_shadow_scalar_result
        ! ----------------------------------------
        ! Argument:  const string * name +intent(in)
        ! Requested: c_string_*_in
        ! Match:     c_string_in
        function c_exclass1_ctor_1(name, SHT_crv) &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_ExClass1_ctor_1")
            use iso_c_binding, only : C_CHAR, C_PTR
            import :: SHROUD_exclass1_capsule
            implicit none
            character(kind=C_CHAR), intent(IN) :: name(*)
            type(SHROUD_exclass1_capsule), intent(OUT) :: SHT_crv
            type(C_PTR) SHT_rv
        end function c_exclass1_ctor_1

        ! ----------------------------------------
        ! Function:  ExClass1
        ! Requested: c_shadow_scalar_result_buf
        ! Match:     c_shadow_scalar_result
        ! ----------------------------------------
        ! Argument:  const string * name +intent(in)+len_trim(Lname)
        ! Requested: c_string_*_in_buf
        ! Match:     c_string_in_buf
        function c_exclass1_ctor_1_bufferify(name, Lname, SHT_crv) &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_ExClass1_ctor_1_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT, C_PTR
            import :: SHROUD_exclass1_capsule
            implicit none
            character(kind=C_CHAR), intent(IN) :: name(*)
            integer(C_INT), value, intent(IN) :: Lname
            type(SHROUD_exclass1_capsule), intent(OUT) :: SHT_crv
            type(C_PTR) SHT_rv
        end function c_exclass1_ctor_1_bufferify

        ! ----------------------------------------
        ! Function:  ~ExClass1
        ! Requested: c_void_scalar_result
        ! Match:     c_default
        subroutine c_exclass1_dtor(self) &
                bind(C, name="AA_example_nested_ExClass1_dtor")
            import :: SHROUD_exclass1_capsule
            implicit none
            type(SHROUD_exclass1_capsule), intent(IN) :: self
        end subroutine c_exclass1_dtor

        ! ----------------------------------------
        ! Function:  int incrementCount
        ! Requested: c_native_scalar_result
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int incr +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        function c_exclass1_increment_count(self, incr) &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_ExClass1_increment_count")
            use iso_c_binding, only : C_INT
            import :: SHROUD_exclass1_capsule
            implicit none
            type(SHROUD_exclass1_capsule), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: incr
            integer(C_INT) :: SHT_rv
        end function c_exclass1_increment_count

        ! ----------------------------------------
        ! Function:  const string & getNameErrorCheck +deref(allocatable)
        ! Requested: c_string_&_result
        ! Match:     c_string_result
        pure function c_exclass1_get_name_error_check(self) &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_ExClass1_get_name_error_check")
            use iso_c_binding, only : C_PTR
            import :: SHROUD_exclass1_capsule
            implicit none
            type(SHROUD_exclass1_capsule), intent(IN) :: self
            type(C_PTR) SHT_rv
        end function c_exclass1_get_name_error_check

        ! ----------------------------------------
        ! Function:  void getNameErrorCheck
        ! Requested: c_void_scalar_result_buf
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  const string & SHF_rv +context(DSHF_rv)+deref(allocatable)+intent(out)
        ! Requested: c_string_&_result_buf_allocatable
        ! Match:     c_string_result_buf_allocatable
        subroutine c_exclass1_get_name_error_check_bufferify(self, &
                DSHF_rv) &
                bind(C, name="AA_example_nested_ExClass1_get_name_error_check_bufferify")
            import :: SHROUD_array, SHROUD_exclass1_capsule
            implicit none
            type(SHROUD_exclass1_capsule), intent(IN) :: self
            type(SHROUD_array), intent(OUT) :: DSHF_rv
        end subroutine c_exclass1_get_name_error_check_bufferify

        ! ----------------------------------------
        ! Function:  const string & getNameArg +deref(result-as-arg)
        ! Requested: c_string_&_result
        ! Match:     c_string_result
        pure function c_exclass1_get_name_arg(self) &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_ExClass1_get_name_arg")
            use iso_c_binding, only : C_PTR
            import :: SHROUD_exclass1_capsule
            implicit none
            type(SHROUD_exclass1_capsule), intent(IN) :: self
            type(C_PTR) SHT_rv
        end function c_exclass1_get_name_arg

        ! ----------------------------------------
        ! Function:  void getNameArg
        ! Requested: c_void_scalar_result_buf
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  string & name +intent(out)+len(Nname)
        ! Requested: c_string_&_result_buf
        ! Match:     c_string_result_buf
        subroutine c_exclass1_get_name_arg_bufferify(self, name, Nname) &
                bind(C, name="AA_example_nested_ExClass1_get_name_arg_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            import :: SHROUD_exclass1_capsule
            implicit none
            type(SHROUD_exclass1_capsule), intent(IN) :: self
            character(kind=C_CHAR), intent(OUT) :: name(*)
            integer(C_INT), value, intent(IN) :: Nname
        end subroutine c_exclass1_get_name_arg_bufferify

        ! ----------------------------------------
        ! Function:  int getValue
        ! Requested: c_native_scalar_result
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int value +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        function c_exclass1_get_value_from_int(self, value) &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_ExClass1_get_value_from_int")
            use iso_c_binding, only : C_INT
            import :: SHROUD_exclass1_capsule
            implicit none
            type(SHROUD_exclass1_capsule), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: value
            integer(C_INT) :: SHT_rv
        end function c_exclass1_get_value_from_int

        ! ----------------------------------------
        ! Function:  long getValue
        ! Requested: c_native_scalar_result
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  long value +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        function c_exclass1_get_value_1(self, value) &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_ExClass1_get_value_1")
            use iso_c_binding, only : C_LONG
            import :: SHROUD_exclass1_capsule
            implicit none
            type(SHROUD_exclass1_capsule), intent(IN) :: self
            integer(C_LONG), value, intent(IN) :: value
            integer(C_LONG) :: SHT_rv
        end function c_exclass1_get_value_1

        ! ----------------------------------------
        ! Function:  bool hasAddr
        ! Requested: c_bool_scalar_result
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  bool in +intent(in)+value
        ! Requested: c_bool_scalar_in
        ! Match:     c_default
        function c_exclass1_has_addr(self, in) &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_ExClass1_has_addr")
            use iso_c_binding, only : C_BOOL
            import :: SHROUD_exclass1_capsule
            implicit none
            type(SHROUD_exclass1_capsule), intent(IN) :: self
            logical(C_BOOL), value, intent(IN) :: in
            logical(C_BOOL) :: SHT_rv
        end function c_exclass1_has_addr

        ! ----------------------------------------
        ! Function:  void SplicerSpecial
        ! Requested: c_void_scalar_result
        ! Match:     c_default
        subroutine c_exclass1_splicer_special(self) &
                bind(C, name="AA_example_nested_ExClass1_splicer_special")
            import :: SHROUD_exclass1_capsule
            implicit none
            type(SHROUD_exclass1_capsule), intent(IN) :: self
        end subroutine c_exclass1_splicer_special

        ! splicer begin namespace.example::nested.class.ExClass1.additional_interfaces
        ! splicer end namespace.example::nested.class.ExClass1.additional_interfaces

        ! ----------------------------------------
        ! Function:  ExClass2
        ! Exact:     c_shadow_scalar_result
        ! ----------------------------------------
        ! Argument:  const string * name +intent(in)+len_trim(trim_name)
        ! Requested: c_string_*_in
        ! Match:     c_string_in
        function c_exclass2_ctor(name, SHT_crv) &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_ExClass2_ctor")
            use iso_c_binding, only : C_CHAR, C_PTR
            import :: SHROUD_exclass2_capsule
            implicit none
            character(kind=C_CHAR), intent(IN) :: name(*)
            type(SHROUD_exclass2_capsule), intent(OUT) :: SHT_crv
            type(C_PTR) SHT_rv
        end function c_exclass2_ctor

        ! ----------------------------------------
        ! Function:  ExClass2
        ! Requested: c_shadow_scalar_result_buf
        ! Match:     c_shadow_scalar_result
        ! ----------------------------------------
        ! Argument:  const string * name +intent(in)+len_trim(trim_name)
        ! Requested: c_string_*_in_buf
        ! Match:     c_string_in_buf
        function c_exclass2_ctor_bufferify(name, trim_name, SHT_crv) &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_ExClass2_ctor_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT, C_PTR
            import :: SHROUD_exclass2_capsule
            implicit none
            character(kind=C_CHAR), intent(IN) :: name(*)
            integer(C_INT), value, intent(IN) :: trim_name
            type(SHROUD_exclass2_capsule), intent(OUT) :: SHT_crv
            type(C_PTR) SHT_rv
        end function c_exclass2_ctor_bufferify

        ! ----------------------------------------
        ! Function:  ~ExClass2
        ! Requested: c_void_scalar_result
        ! Match:     c_default
        subroutine c_exclass2_dtor(self) &
                bind(C, name="AA_example_nested_ExClass2_dtor")
            import :: SHROUD_exclass2_capsule
            implicit none
            type(SHROUD_exclass2_capsule), intent(IN) :: self
        end subroutine c_exclass2_dtor

        ! ----------------------------------------
        ! Function:  const string & getName +deref(result-as-arg)+len(aa_exclass2_get_name_length({F_this}%{F_derived_member}))
        ! Requested: c_string_&_result
        ! Match:     c_string_result
        pure function c_exclass2_get_name(self) &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_ExClass2_get_name")
            use iso_c_binding, only : C_PTR
            import :: SHROUD_exclass2_capsule
            implicit none
            type(SHROUD_exclass2_capsule), intent(IN) :: self
            type(C_PTR) SHT_rv
        end function c_exclass2_get_name

        ! ----------------------------------------
        ! Function:  void getName +len(aa_exclass2_get_name_length({F_this}%{F_derived_member}))
        ! Requested: c_void_scalar_result_buf
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  string & SHF_rv +intent(out)+len(NSHF_rv)
        ! Requested: c_string_&_result_buf
        ! Match:     c_string_result_buf
        subroutine c_exclass2_get_name_bufferify(self, SHF_rv, NSHF_rv) &
                bind(C, name="AA_example_nested_ExClass2_get_name_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            import :: SHROUD_exclass2_capsule
            implicit none
            type(SHROUD_exclass2_capsule), intent(IN) :: self
            character(kind=C_CHAR), intent(OUT) :: SHF_rv(*)
            integer(C_INT), value, intent(IN) :: NSHF_rv
        end subroutine c_exclass2_get_name_bufferify

        ! ----------------------------------------
        ! Function:  const string & getName2 +deref(allocatable)
        ! Requested: c_string_&_result
        ! Match:     c_string_result
        function c_exclass2_get_name2(self) &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_ExClass2_get_name2")
            use iso_c_binding, only : C_PTR
            import :: SHROUD_exclass2_capsule
            implicit none
            type(SHROUD_exclass2_capsule), intent(IN) :: self
            type(C_PTR) SHT_rv
        end function c_exclass2_get_name2

        ! ----------------------------------------
        ! Function:  void getName2
        ! Requested: c_void_scalar_result_buf
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  const string & SHF_rv +context(DSHF_rv)+deref(allocatable)+intent(out)
        ! Requested: c_string_&_result_buf_allocatable
        ! Match:     c_string_result_buf_allocatable
        subroutine c_exclass2_get_name2_bufferify(self, DSHF_rv) &
                bind(C, name="AA_example_nested_ExClass2_get_name2_bufferify")
            import :: SHROUD_array, SHROUD_exclass2_capsule
            implicit none
            type(SHROUD_exclass2_capsule), intent(IN) :: self
            type(SHROUD_array), intent(OUT) :: DSHF_rv
        end subroutine c_exclass2_get_name2_bufferify

        ! ----------------------------------------
        ! Function:  string & getName3 +deref(allocatable)
        ! Requested: c_string_&_result
        ! Match:     c_string_result
        pure function c_exclass2_get_name3(self) &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_ExClass2_get_name3")
            use iso_c_binding, only : C_PTR
            import :: SHROUD_exclass2_capsule
            implicit none
            type(SHROUD_exclass2_capsule), intent(IN) :: self
            type(C_PTR) SHT_rv
        end function c_exclass2_get_name3

        ! ----------------------------------------
        ! Function:  void getName3
        ! Requested: c_void_scalar_result_buf
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  string & SHF_rv +context(DSHF_rv)+deref(allocatable)+intent(out)
        ! Requested: c_string_&_result_buf_allocatable
        ! Match:     c_string_result_buf_allocatable
        subroutine c_exclass2_get_name3_bufferify(self, DSHF_rv) &
                bind(C, name="AA_example_nested_ExClass2_get_name3_bufferify")
            import :: SHROUD_array, SHROUD_exclass2_capsule
            implicit none
            type(SHROUD_exclass2_capsule), intent(IN) :: self
            type(SHROUD_array), intent(OUT) :: DSHF_rv
        end subroutine c_exclass2_get_name3_bufferify

        ! ----------------------------------------
        ! Function:  string & getName4 +deref(allocatable)
        ! Requested: c_string_&_result
        ! Match:     c_string_result
        function c_exclass2_get_name4(self) &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_ExClass2_get_name4")
            use iso_c_binding, only : C_PTR
            import :: SHROUD_exclass2_capsule
            implicit none
            type(SHROUD_exclass2_capsule), intent(IN) :: self
            type(C_PTR) SHT_rv
        end function c_exclass2_get_name4

        ! ----------------------------------------
        ! Function:  void getName4
        ! Requested: c_void_scalar_result_buf
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  string & SHF_rv +context(DSHF_rv)+deref(allocatable)+intent(out)
        ! Requested: c_string_&_result_buf_allocatable
        ! Match:     c_string_result_buf_allocatable
        subroutine c_exclass2_get_name4_bufferify(self, DSHF_rv) &
                bind(C, name="AA_example_nested_ExClass2_get_name4_bufferify")
            import :: SHROUD_array, SHROUD_exclass2_capsule
            implicit none
            type(SHROUD_exclass2_capsule), intent(IN) :: self
            type(SHROUD_array), intent(OUT) :: DSHF_rv
        end subroutine c_exclass2_get_name4_bufferify

        ! ----------------------------------------
        ! Function:  int GetNameLength
        ! Requested: c_native_scalar_result
        ! Match:     c_default
        pure function c_exclass2_get_name_length(self) &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_ExClass2_get_name_length")
            use iso_c_binding, only : C_INT
            import :: SHROUD_exclass2_capsule
            implicit none
            type(SHROUD_exclass2_capsule), intent(IN) :: self
            integer(C_INT) :: SHT_rv
        end function c_exclass2_get_name_length

        ! ----------------------------------------
        ! Function:  ExClass1 * get_class1
        ! Requested: c_shadow_*_result
        ! Match:     c_shadow_result
        ! ----------------------------------------
        ! Argument:  const ExClass1 * in +intent(in)
        ! Requested: c_shadow_*_in
        ! Match:     c_shadow_in
        function c_exclass2_get_class1(self, in, SHT_crv) &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_ExClass2_get_class1")
            use iso_c_binding, only : C_PTR
            import :: SHROUD_exclass1_capsule, SHROUD_exclass2_capsule
            implicit none
            type(SHROUD_exclass2_capsule), intent(IN) :: self
            type(SHROUD_exclass1_capsule), intent(IN) :: in
            type(SHROUD_exclass1_capsule), intent(OUT) :: SHT_crv
            type(C_PTR) SHT_rv
        end function c_exclass2_get_class1

        ! ----------------------------------------
        ! Function:  void * declare
        ! Requested: c_void_*_result
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  TypeID type +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        subroutine c_exclass2_declare_0(self, type) &
                bind(C, name="AA_example_nested_ExClass2_declare_0")
            use iso_c_binding, only : C_INT
            import :: SHROUD_exclass2_capsule
            implicit none
            type(SHROUD_exclass2_capsule), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: type
        end subroutine c_exclass2_declare_0

        ! ----------------------------------------
        ! Function:  void * declare
        ! Requested: c_void_*_result
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  TypeID type +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  SidreLength len=1 +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        subroutine c_exclass2_declare_1(self, type, len) &
                bind(C, name="AA_example_nested_ExClass2_declare_1")
            use iso_c_binding, only : C_INT, C_LONG
            import :: SHROUD_exclass2_capsule
            implicit none
            type(SHROUD_exclass2_capsule), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: type
            integer(C_LONG), value, intent(IN) :: len
        end subroutine c_exclass2_declare_1

        ! ----------------------------------------
        ! Function:  void destroyall
        ! Requested: c_void_scalar_result
        ! Match:     c_default
        subroutine c_exclass2_destroyall(self) &
                bind(C, name="AA_example_nested_ExClass2_destroyall")
            import :: SHROUD_exclass2_capsule
            implicit none
            type(SHROUD_exclass2_capsule), intent(IN) :: self
        end subroutine c_exclass2_destroyall

        ! ----------------------------------------
        ! Function:  TypeID getTypeID
        ! Requested: c_native_scalar_result
        ! Match:     c_default
        pure function c_exclass2_get_type_id(self) &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_ExClass2_get_type_id")
            use iso_c_binding, only : C_INT
            import :: SHROUD_exclass2_capsule
            implicit none
            type(SHROUD_exclass2_capsule), intent(IN) :: self
            integer(C_INT) :: SHT_rv
        end function c_exclass2_get_type_id

        ! ----------------------------------------
        ! Function:  void setValue
        ! Requested: c_void_scalar_result
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int value +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        subroutine c_exclass2_set_value_int(self, value) &
                bind(C, name="AA_example_nested_ExClass2_set_value_int")
            use iso_c_binding, only : C_INT
            import :: SHROUD_exclass2_capsule
            implicit none
            type(SHROUD_exclass2_capsule), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: value
        end subroutine c_exclass2_set_value_int

        ! ----------------------------------------
        ! Function:  void setValue
        ! Requested: c_void_scalar_result
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  long value +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        subroutine c_exclass2_set_value_long(self, value) &
                bind(C, name="AA_example_nested_ExClass2_set_value_long")
            use iso_c_binding, only : C_LONG
            import :: SHROUD_exclass2_capsule
            implicit none
            type(SHROUD_exclass2_capsule), intent(IN) :: self
            integer(C_LONG), value, intent(IN) :: value
        end subroutine c_exclass2_set_value_long

        ! ----------------------------------------
        ! Function:  void setValue
        ! Requested: c_void_scalar_result
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  float value +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        subroutine c_exclass2_set_value_float(self, value) &
                bind(C, name="AA_example_nested_ExClass2_set_value_float")
            use iso_c_binding, only : C_FLOAT
            import :: SHROUD_exclass2_capsule
            implicit none
            type(SHROUD_exclass2_capsule), intent(IN) :: self
            real(C_FLOAT), value, intent(IN) :: value
        end subroutine c_exclass2_set_value_float

        ! ----------------------------------------
        ! Function:  void setValue
        ! Requested: c_void_scalar_result
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  double value +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        subroutine c_exclass2_set_value_double(self, value) &
                bind(C, name="AA_example_nested_ExClass2_set_value_double")
            use iso_c_binding, only : C_DOUBLE
            import :: SHROUD_exclass2_capsule
            implicit none
            type(SHROUD_exclass2_capsule), intent(IN) :: self
            real(C_DOUBLE), value, intent(IN) :: value
        end subroutine c_exclass2_set_value_double

        ! ----------------------------------------
        ! Function:  int getValue
        ! Requested: c_native_scalar_result
        ! Match:     c_default
        function c_exclass2_get_value_int(self) &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_ExClass2_get_value_int")
            use iso_c_binding, only : C_INT
            import :: SHROUD_exclass2_capsule
            implicit none
            type(SHROUD_exclass2_capsule), intent(IN) :: self
            integer(C_INT) :: SHT_rv
        end function c_exclass2_get_value_int

        ! ----------------------------------------
        ! Function:  double getValue
        ! Requested: c_native_scalar_result
        ! Match:     c_default
        function c_exclass2_get_value_double(self) &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_ExClass2_get_value_double")
            use iso_c_binding, only : C_DOUBLE
            import :: SHROUD_exclass2_capsule
            implicit none
            type(SHROUD_exclass2_capsule), intent(IN) :: self
            real(C_DOUBLE) :: SHT_rv
        end function c_exclass2_get_value_double

        ! splicer begin namespace.example::nested.class.ExClass2.additional_interfaces
        ! splicer end namespace.example::nested.class.ExClass2.additional_interfaces

        ! ----------------------------------------
        ! Function:  void local_function1
        ! Requested: c_void_scalar_result
        ! Match:     c_default
        subroutine local_function1() &
                bind(C, name="AA_example_nested_local_function1")
            implicit none
        end subroutine local_function1

        ! ----------------------------------------
        ! Function:  bool isNameValid
        ! Requested: c_bool_scalar_result
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  const std::string & name +intent(in)
        ! Requested: c_string_&_in
        ! Match:     c_string_in
        function c_is_name_valid(name) &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_is_name_valid")
            use iso_c_binding, only : C_BOOL, C_CHAR
            implicit none
            character(kind=C_CHAR), intent(IN) :: name(*)
            logical(C_BOOL) :: SHT_rv
        end function c_is_name_valid

        ! ----------------------------------------
        ! Function:  bool isNameValid
        ! Requested: c_bool_scalar_result_buf
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  const std::string & name +intent(in)+len_trim(Lname)
        ! Requested: c_string_&_in_buf
        ! Match:     c_string_in_buf
        function c_is_name_valid_bufferify(name, Lname) &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_is_name_valid_bufferify")
            use iso_c_binding, only : C_BOOL, C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: name(*)
            integer(C_INT), value, intent(IN) :: Lname
            logical(C_BOOL) :: SHT_rv
        end function c_is_name_valid_bufferify

        ! ----------------------------------------
        ! Function:  bool isInitialized
        ! Requested: c_bool_scalar_result
        ! Match:     c_default
        function c_is_initialized() &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_is_initialized")
            use iso_c_binding, only : C_BOOL
            implicit none
            logical(C_BOOL) :: SHT_rv
        end function c_is_initialized

        ! ----------------------------------------
        ! Function:  void test_names
        ! Requested: c_void_scalar_result
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  const std::string & name +intent(in)
        ! Requested: c_string_&_in
        ! Match:     c_string_in
        subroutine c_test_names(name) &
                bind(C, name="AA_example_nested_test_names")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(IN) :: name(*)
        end subroutine c_test_names

        ! ----------------------------------------
        ! Function:  void test_names
        ! Requested: c_void_scalar_result_buf
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  const std::string & name +intent(in)+len_trim(Lname)
        ! Requested: c_string_&_in_buf
        ! Match:     c_string_in_buf
        subroutine c_test_names_bufferify(name, Lname) &
                bind(C, name="AA_example_nested_test_names_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: name(*)
            integer(C_INT), value, intent(IN) :: Lname
        end subroutine c_test_names_bufferify

        ! ----------------------------------------
        ! Function:  void test_names
        ! Requested: c_void_scalar_result
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  const std::string & name +intent(in)
        ! Requested: c_string_&_in
        ! Match:     c_string_in
        ! ----------------------------------------
        ! Argument:  int flag +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        subroutine c_test_names_flag(name, flag) &
                bind(C, name="AA_example_nested_test_names_flag")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: name(*)
            integer(C_INT), value, intent(IN) :: flag
        end subroutine c_test_names_flag

        ! ----------------------------------------
        ! Function:  void test_names
        ! Requested: c_void_scalar_result_buf
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  const std::string & name +intent(in)+len_trim(Lname)
        ! Requested: c_string_&_in_buf
        ! Match:     c_string_in_buf
        ! ----------------------------------------
        ! Argument:  int flag +intent(in)+value
        ! Requested: c_native_scalar_in_buf
        ! Match:     c_default
        subroutine c_test_names_flag_bufferify(name, Lname, flag) &
                bind(C, name="AA_example_nested_test_names_flag_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: name(*)
            integer(C_INT), value, intent(IN) :: Lname
            integer(C_INT), value, intent(IN) :: flag
        end subroutine c_test_names_flag_bufferify

        ! ----------------------------------------
        ! Function:  void testoptional
        ! Requested: c_void_scalar_result
        ! Match:     c_default
        subroutine c_testoptional_0() &
                bind(C, name="AA_example_nested_testoptional_0")
            implicit none
        end subroutine c_testoptional_0

        ! ----------------------------------------
        ! Function:  void testoptional
        ! Requested: c_void_scalar_result
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int i=1 +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        subroutine c_testoptional_1(i) &
                bind(C, name="AA_example_nested_testoptional_1")
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT), value, intent(IN) :: i
        end subroutine c_testoptional_1

        ! ----------------------------------------
        ! Function:  void testoptional
        ! Requested: c_void_scalar_result
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int i=1 +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  long j=2 +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        subroutine c_testoptional_2(i, j) &
                bind(C, name="AA_example_nested_testoptional_2")
            use iso_c_binding, only : C_INT, C_LONG
            implicit none
            integer(C_INT), value, intent(IN) :: i
            integer(C_LONG), value, intent(IN) :: j
        end subroutine c_testoptional_2

        ! ----------------------------------------
        ! Function:  size_t test_size_t
        ! Requested: c_native_scalar_result
        ! Match:     c_default
        function test_size_t() &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_test_size_t")
            use iso_c_binding, only : C_SIZE_T
            implicit none
            integer(C_SIZE_T) :: SHT_rv
        end function test_size_t

#ifdef HAVE_MPI
        ! ----------------------------------------
        ! Function:  void testmpi
        ! Requested: c_void_scalar_result
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  MPI_Comm comm +intent(in)+value
        ! Requested: c_unknown_scalar_in
        ! Match:     c_default
        subroutine c_testmpi_mpi(comm) &
                bind(C, name="AA_example_nested_testmpi_mpi")
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT), value, intent(IN) :: comm
        end subroutine c_testmpi_mpi
#endif

#ifndef HAVE_MPI
        ! ----------------------------------------
        ! Function:  void testmpi
        ! Requested: c_void_scalar_result
        ! Match:     c_default
        subroutine c_testmpi_serial() &
                bind(C, name="AA_example_nested_testmpi_serial")
            implicit none
        end subroutine c_testmpi_serial
#endif

        ! ----------------------------------------
        ! Function:  void FuncPtr1
        ! Requested: c_void_scalar_result
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  void ( * get)() +intent(in)+value
        ! Requested: c_void_scalar_in
        ! Match:     c_default
        subroutine func_ptr1(get) &
                bind(C, name="AA_example_nested_func_ptr1")
            import :: func_ptr1_get
            implicit none
            procedure(func_ptr1_get) :: get
        end subroutine func_ptr1

        ! ----------------------------------------
        ! Function:  void FuncPtr2
        ! Requested: c_void_scalar_result
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  double * ( * get)() +intent(in)
        ! Requested: c_native_*_in
        ! Match:     c_default
        subroutine func_ptr2(get) &
                bind(C, name="AA_example_nested_func_ptr2")
            import :: func_ptr2_get
            implicit none
            procedure(func_ptr2_get) :: get
        end subroutine func_ptr2

        ! ----------------------------------------
        ! Function:  void FuncPtr3
        ! Requested: c_void_scalar_result
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  double ( * get)(int i +value, int +value) +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        subroutine c_func_ptr3(get) &
                bind(C, name="AA_example_nested_func_ptr3")
            import :: func_ptr3_get
            implicit none
            procedure(func_ptr3_get) :: get
        end subroutine c_func_ptr3

        ! ----------------------------------------
        ! Function:  void FuncPtr4
        ! Requested: c_void_scalar_result
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  double ( * get)(double +value, int +value) +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        subroutine c_func_ptr4(get) &
                bind(C, name="AA_example_nested_func_ptr4")
            import :: custom_funptr
            implicit none
            procedure(custom_funptr) :: get
        end subroutine c_func_ptr4

        ! ----------------------------------------
        ! Function:  void FuncPtr5
        ! Requested: c_void_scalar_result
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  void ( * get)(int verylongname1 +value, int verylongname2 +value, int verylongname3 +value, int verylongname4 +value, int verylongname5 +value, int verylongname6 +value, int verylongname7 +value, int verylongname8 +value, int verylongname9 +value, int verylongname10 +value) +intent(in)+value
        ! Requested: c_void_scalar_in
        ! Match:     c_default
        subroutine func_ptr5(get) &
                bind(C, name="AA_example_nested_func_ptr5")
            import :: func_ptr5_get
            implicit none
            procedure(func_ptr5_get) :: get
        end subroutine func_ptr5

        ! ----------------------------------------
        ! Function:  void verylongfunctionname1
        ! Requested: c_void_scalar_result
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int * verylongname1 +intent(inout)
        ! Requested: c_native_*_inout
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int * verylongname2 +intent(inout)
        ! Requested: c_native_*_inout
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int * verylongname3 +intent(inout)
        ! Requested: c_native_*_inout
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int * verylongname4 +intent(inout)
        ! Requested: c_native_*_inout
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int * verylongname5 +intent(inout)
        ! Requested: c_native_*_inout
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int * verylongname6 +intent(inout)
        ! Requested: c_native_*_inout
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int * verylongname7 +intent(inout)
        ! Requested: c_native_*_inout
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int * verylongname8 +intent(inout)
        ! Requested: c_native_*_inout
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int * verylongname9 +intent(inout)
        ! Requested: c_native_*_inout
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int * verylongname10 +intent(inout)
        ! Requested: c_native_*_inout
        ! Match:     c_default
        subroutine c_verylongfunctionname1(verylongname1, verylongname2, &
                verylongname3, verylongname4, verylongname5, &
                verylongname6, verylongname7, verylongname8, &
                verylongname9, verylongname10) &
                bind(C, name="AA_example_nested_verylongfunctionname1")
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT), intent(INOUT) :: verylongname1
            integer(C_INT), intent(INOUT) :: verylongname2
            integer(C_INT), intent(INOUT) :: verylongname3
            integer(C_INT), intent(INOUT) :: verylongname4
            integer(C_INT), intent(INOUT) :: verylongname5
            integer(C_INT), intent(INOUT) :: verylongname6
            integer(C_INT), intent(INOUT) :: verylongname7
            integer(C_INT), intent(INOUT) :: verylongname8
            integer(C_INT), intent(INOUT) :: verylongname9
            integer(C_INT), intent(INOUT) :: verylongname10
        end subroutine c_verylongfunctionname1

        ! ----------------------------------------
        ! Function:  int verylongfunctionname2
        ! Requested: c_native_scalar_result
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int verylongname1 +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int verylongname2 +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int verylongname3 +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int verylongname4 +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int verylongname5 +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int verylongname6 +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int verylongname7 +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int verylongname8 +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int verylongname9 +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int verylongname10 +intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        function c_verylongfunctionname2(verylongname1, verylongname2, &
                verylongname3, verylongname4, verylongname5, &
                verylongname6, verylongname7, verylongname8, &
                verylongname9, verylongname10) &
                result(SHT_rv) &
                bind(C, name="AA_example_nested_verylongfunctionname2")
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT), value, intent(IN) :: verylongname1
            integer(C_INT), value, intent(IN) :: verylongname2
            integer(C_INT), value, intent(IN) :: verylongname3
            integer(C_INT), value, intent(IN) :: verylongname4
            integer(C_INT), value, intent(IN) :: verylongname5
            integer(C_INT), value, intent(IN) :: verylongname6
            integer(C_INT), value, intent(IN) :: verylongname7
            integer(C_INT), value, intent(IN) :: verylongname8
            integer(C_INT), value, intent(IN) :: verylongname9
            integer(C_INT), value, intent(IN) :: verylongname10
            integer(C_INT) :: SHT_rv
        end function c_verylongfunctionname2

        ! ----------------------------------------
        ! Function:  void cos_doubles
        ! Requested: c_void_scalar_result
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  double * in +intent(in)+rank(2)
        ! Requested: c_native_*_in
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  double * out +deref(allocatable)+dimension(shape(in))+intent(out)
        ! Requested: c_native_*_out_allocatable
        ! Match:     c_default
        ! ----------------------------------------
        ! Argument:  int sizein +implied(size(in))+intent(in)+value
        ! Requested: c_native_scalar_in
        ! Match:     c_default
        subroutine c_cos_doubles(in, out, sizein) &
                bind(C, name="AA_example_nested_cos_doubles")
            use iso_c_binding, only : C_DOUBLE, C_INT
            implicit none
            real(C_DOUBLE), intent(IN) :: in(*)
            real(C_DOUBLE), intent(OUT) :: out(*)
            integer(C_INT), value, intent(IN) :: sizein
        end subroutine c_cos_doubles

        ! splicer begin namespace.example::nested.additional_interfaces
        ! splicer end namespace.example::nested.additional_interfaces
    end interface

    interface exclass1
        module procedure exclass1_ctor_0
        module procedure exclass1_ctor_1
    end interface exclass1

    interface exclass2
        module procedure exclass2_ctor
    end interface exclass2

    interface test_names
        module procedure test_names
        module procedure test_names_flag
    end interface test_names

    interface testmpi
#ifdef HAVE_MPI
        module procedure testmpi_mpi
#endif
#ifndef HAVE_MPI
        module procedure testmpi_serial
#endif
    end interface testmpi

    interface testoptional
        module procedure testoptional_0
        module procedure testoptional_1
        module procedure testoptional_2
    end interface testoptional

    interface
        ! helper copy_string
        ! Copy the char* or std::string in context into c_var.
        subroutine SHROUD_copy_string_and_free(context, c_var, c_var_size) &
             bind(c,name="AA_ShroudCopyStringAndFree")
            use, intrinsic :: iso_c_binding, only : C_CHAR, C_SIZE_T
            import SHROUD_array
            type(SHROUD_array), intent(IN) :: context
            character(kind=C_CHAR), intent(OUT) :: c_var(*)
            integer(C_SIZE_T), value :: c_var_size
        end subroutine SHROUD_copy_string_and_free
    end interface

contains

    ! ----------------------------------------
    ! Function:  ExClass1
    ! ExClass1
    ! Exact:     f_shadow_ctor
    ! Exact:     c_shadow_ctor
    function exclass1_ctor_0() &
            result(SHT_rv)
        use iso_c_binding, only : C_PTR
        type(exclass1) :: SHT_rv
        ! splicer begin namespace.example::nested.class.ExClass1.method.ctor_0
        type(C_PTR) :: SHT_prv
        SHT_prv = c_exclass1_ctor_0(SHT_rv%cxxmem)
        ! splicer end namespace.example::nested.class.ExClass1.method.ctor_0
    end function exclass1_ctor_0

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  ExClass1
    ! ExClass1
    ! Exact:     f_shadow_ctor
    ! Exact:     c_shadow_ctor
    ! ----------------------------------------
    ! Argument:  const string * name +intent(in)
    ! Requested: f_string_*_in
    ! Match:     f_default
    ! Argument:  const string * name +intent(in)+len_trim(Lname)
    ! Requested: c_string_*_in_buf
    ! Match:     c_string_in_buf
    !>
    !! \brief constructor
    !!
    !! longer description
    !! usually multiple lines
    !!
    !! \return return new instance
    !<
    function exclass1_ctor_1(name) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT, C_PTR
        character(len=*), intent(IN) :: name
        type(exclass1) :: SHT_rv
        ! splicer begin namespace.example::nested.class.ExClass1.method.ctor_1
        type(C_PTR) :: SHT_prv
        SHT_prv = c_exclass1_ctor_1_bufferify(name, &
            len_trim(name, kind=C_INT), SHT_rv%cxxmem)
        ! splicer end namespace.example::nested.class.ExClass1.method.ctor_1
    end function exclass1_ctor_1

    ! ----------------------------------------
    ! Function:  ~ExClass1
    ! ~ExClass1
    ! Requested: f_shadow_dtor
    ! Match:     f_default
    ! Exact:     c_shadow_dtor
    !>
    !! \brief destructor
    !!
    !! longer description joined with previous line
    !<
    subroutine exclass1_dtor(obj)
        class(exclass1) :: obj
        ! splicer begin namespace.example::nested.class.ExClass1.method.delete
        call c_exclass1_dtor(obj%cxxmem)
        ! splicer end namespace.example::nested.class.ExClass1.method.delete
    end subroutine exclass1_dtor

    ! ----------------------------------------
    ! Function:  int incrementCount
    ! int incrementCount
    ! Requested: f_native_scalar_result
    ! Match:     f_default
    ! Requested: c_native_scalar_result
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int incr +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    function exclass1_increment_count(obj, incr) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        class(exclass1) :: obj
        integer(C_INT), value, intent(IN) :: incr
        integer(C_INT) :: SHT_rv
        ! splicer begin namespace.example::nested.class.ExClass1.method.increment_count
        SHT_rv = c_exclass1_increment_count(obj%cxxmem, incr)
        ! splicer end namespace.example::nested.class.ExClass1.method.increment_count
    end function exclass1_increment_count

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const string & getNameErrorCheck +deref(allocatable)
    ! const string & getNameErrorCheck +deref(allocatable)
    ! Requested: f_string_scalar_result_allocatable
    ! Match:     f_string_result_allocatable
    ! Function:  void getNameErrorCheck
    ! Exact:     c_string_scalar_result_buf
    ! ----------------------------------------
    ! Argument:  const string & SHF_rv +context(DSHF_rv)+deref(allocatable)+intent(out)
    ! Requested: f_string_&_result_allocatable
    ! Match:     f_string_result_allocatable
    ! Requested: c_string_&_result_buf_allocatable
    ! Match:     c_string_result_buf_allocatable
    function exclass1_get_name_error_check(obj) &
            result(SHT_rv)
        class(exclass1) :: obj
        type(SHROUD_array) :: DSHF_rv
        character(len=:), allocatable :: SHT_rv
        ! splicer begin namespace.example::nested.class.ExClass1.method.get_name_error_check
        call c_exclass1_get_name_error_check_bufferify(obj%cxxmem, &
            DSHF_rv)
        allocate(character(len=DSHF_rv%elem_len):: SHT_rv)
        call SHROUD_copy_string_and_free(DSHF_rv, SHT_rv, DSHF_rv%elem_len)
        ! splicer end namespace.example::nested.class.ExClass1.method.get_name_error_check
    end function exclass1_get_name_error_check

    ! Generated by arg_to_buffer - arg_to_buffer
    ! ----------------------------------------
    ! Function:  void getNameArg
    ! void getNameArg
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  string & name +intent(out)+len(Nname)
    ! Requested: f_string_&_result
    ! Match:     f_default
    ! Requested: c_string_&_result_buf
    ! Match:     c_string_result_buf
    subroutine exclass1_get_name_arg(obj, name)
        use iso_c_binding, only : C_INT
        class(exclass1) :: obj
        character(len=*), intent(OUT) :: name
        ! splicer begin namespace.example::nested.class.ExClass1.method.get_name_arg
        call c_exclass1_get_name_arg_bufferify(obj%cxxmem, name, &
            len(name, kind=C_INT))
        ! splicer end namespace.example::nested.class.ExClass1.method.get_name_arg
    end subroutine exclass1_get_name_arg

    ! ----------------------------------------
    ! Function:  int getValue
    ! int getValue
    ! Requested: f_native_scalar_result
    ! Match:     f_default
    ! Requested: c_native_scalar_result
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int value +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    function exclass1_get_value_from_int(obj, value) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        class(exclass1) :: obj
        integer(C_INT), value, intent(IN) :: value
        integer(C_INT) :: SHT_rv
        ! splicer begin namespace.example::nested.class.ExClass1.method.get_value_from_int
        SHT_rv = c_exclass1_get_value_from_int(obj%cxxmem, value)
        ! splicer end namespace.example::nested.class.ExClass1.method.get_value_from_int
    end function exclass1_get_value_from_int

    ! ----------------------------------------
    ! Function:  long getValue
    ! long getValue
    ! Requested: f_native_scalar_result
    ! Match:     f_default
    ! Requested: c_native_scalar_result
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  long value +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    function exclass1_get_value_1(obj, value) &
            result(SHT_rv)
        use iso_c_binding, only : C_LONG
        class(exclass1) :: obj
        integer(C_LONG), value, intent(IN) :: value
        integer(C_LONG) :: SHT_rv
        ! splicer begin namespace.example::nested.class.ExClass1.method.get_value_1
        SHT_rv = c_exclass1_get_value_1(obj%cxxmem, value)
        ! splicer end namespace.example::nested.class.ExClass1.method.get_value_1
    end function exclass1_get_value_1

    ! ----------------------------------------
    ! Function:  bool hasAddr
    ! bool hasAddr
    ! Requested: f_bool_scalar_result
    ! Match:     f_bool_result
    ! Requested: c_bool_scalar_result
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  bool in +intent(in)+value
    ! Requested: f_bool_scalar_in
    ! Match:     f_bool_in
    ! Requested: c_bool_scalar_in
    ! Match:     c_default
    function exclass1_has_addr(obj, in) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL
        class(exclass1) :: obj
        logical, value, intent(IN) :: in
        logical :: SHT_rv
        ! splicer begin namespace.example::nested.class.ExClass1.method.has_addr
        logical(C_BOOL) SH_in
        SH_in = in  ! coerce to C_BOOL
        SHT_rv = c_exclass1_has_addr(obj%cxxmem, SH_in)
        ! splicer end namespace.example::nested.class.ExClass1.method.has_addr
    end function exclass1_has_addr

    ! ----------------------------------------
    ! Function:  void SplicerSpecial
    ! void SplicerSpecial
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    subroutine exclass1_splicer_special(obj)
        class(exclass1) :: obj
        ! splicer begin namespace.example::nested.class.ExClass1.method.splicer_special
        blah blah blah
        ! splicer end namespace.example::nested.class.ExClass1.method.splicer_special
    end subroutine exclass1_splicer_special

    ! Return pointer to C++ memory.
    function exclass1_yadda(obj) result (cxxptr)
        use iso_c_binding, only: C_PTR
        class(exclass1), intent(IN) :: obj
        type(C_PTR) :: cxxptr
        cxxptr = obj%cxxmem%addr
    end function exclass1_yadda

    function exclass1_associated(obj) result (rv)
        use iso_c_binding, only: c_associated
        class(exclass1), intent(IN) :: obj
        logical rv
        rv = c_associated(obj%cxxmem%addr)
    end function exclass1_associated

    ! splicer begin namespace.example::nested.class.ExClass1.additional_functions
      insert extra functions here
    ! splicer end namespace.example::nested.class.ExClass1.additional_functions

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  ExClass2
    ! ExClass2
    ! Exact:     f_shadow_ctor
    ! Exact:     c_shadow_ctor
    ! ----------------------------------------
    ! Argument:  const string * name +intent(in)+len_trim(trim_name)
    ! Requested: f_string_*_in
    ! Match:     f_default
    ! Requested: c_string_*_in_buf
    ! Match:     c_string_in_buf
    !>
    !! \brief constructor
    !!
    !<
    function exclass2_ctor(name) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT, C_PTR
        character(len=*), intent(IN) :: name
        type(exclass2) :: SHT_rv
        ! splicer begin namespace.example::nested.class.ExClass2.method.ctor
        type(C_PTR) :: SHT_prv
        SHT_prv = c_exclass2_ctor_bufferify(name, &
            len_trim(name, kind=C_INT), SHT_rv%cxxmem)
        ! splicer end namespace.example::nested.class.ExClass2.method.ctor
    end function exclass2_ctor

    ! ----------------------------------------
    ! Function:  ~ExClass2
    ! ~ExClass2
    ! Requested: f_shadow_dtor
    ! Match:     f_default
    ! Exact:     c_shadow_dtor
    !>
    !! \brief destructor
    !!
    !<
    subroutine exclass2_dtor(obj)
        class(exclass2) :: obj
        ! splicer begin namespace.example::nested.class.ExClass2.method.delete
        call c_exclass2_dtor(obj%cxxmem)
        ! splicer end namespace.example::nested.class.ExClass2.method.delete
    end subroutine exclass2_dtor

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const string & getName +deref(result-as-arg)+len(aa_exclass2_get_name_length({F_this}%{F_derived_member}))
    ! const string & getName +deref(result-as-arg)+len(aa_exclass2_get_name_length({F_this}%{F_derived_member}))
    ! Requested: f_string_scalar_result_result-as-arg
    ! Match:     f_default
    ! Function:  void getName +len(aa_exclass2_get_name_length({F_this}%{F_derived_member}))
    ! Exact:     c_string_scalar_result_buf
    ! ----------------------------------------
    ! Argument:  string & SHF_rv +intent(out)+len(NSHF_rv)
    ! Requested: f_string_&_result
    ! Match:     f_default
    ! Requested: c_string_&_result_buf
    ! Match:     c_string_result_buf
    function exclass2_get_name(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        class(exclass2) :: obj
        character(len=aa_exclass2_get_name_length({F_this}%{F_derived_member})) :: SHT_rv
        ! splicer begin namespace.example::nested.class.ExClass2.method.get_name
        call c_exclass2_get_name_bufferify(obj%cxxmem, SHT_rv, &
            len(SHT_rv, kind=C_INT))
        ! splicer end namespace.example::nested.class.ExClass2.method.get_name
    end function exclass2_get_name

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const string & getName2 +deref(allocatable)
    ! const string & getName2 +deref(allocatable)
    ! Requested: f_string_scalar_result_allocatable
    ! Match:     f_string_result_allocatable
    ! Function:  void getName2
    ! Exact:     c_string_scalar_result_buf
    ! ----------------------------------------
    ! Argument:  const string & SHF_rv +context(DSHF_rv)+deref(allocatable)+intent(out)
    ! Requested: f_string_&_result_allocatable
    ! Match:     f_string_result_allocatable
    ! Requested: c_string_&_result_buf_allocatable
    ! Match:     c_string_result_buf_allocatable
    function exclass2_get_name2(obj) &
            result(SHT_rv)
        class(exclass2) :: obj
        type(SHROUD_array) :: DSHF_rv
        character(len=:), allocatable :: SHT_rv
        ! splicer begin namespace.example::nested.class.ExClass2.method.get_name2
        call c_exclass2_get_name2_bufferify(obj%cxxmem, DSHF_rv)
        allocate(character(len=DSHF_rv%elem_len):: SHT_rv)
        call SHROUD_copy_string_and_free(DSHF_rv, SHT_rv, DSHF_rv%elem_len)
        ! splicer end namespace.example::nested.class.ExClass2.method.get_name2
    end function exclass2_get_name2

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  string & getName3 +deref(allocatable)
    ! string & getName3 +deref(allocatable)
    ! Requested: f_string_scalar_result_allocatable
    ! Match:     f_string_result_allocatable
    ! Function:  void getName3
    ! Exact:     c_string_scalar_result_buf
    ! ----------------------------------------
    ! Argument:  string & SHF_rv +context(DSHF_rv)+deref(allocatable)+intent(out)
    ! Requested: f_string_&_result_allocatable
    ! Match:     f_string_result_allocatable
    ! Requested: c_string_&_result_buf_allocatable
    ! Match:     c_string_result_buf_allocatable
    function exclass2_get_name3(obj) &
            result(SHT_rv)
        class(exclass2) :: obj
        type(SHROUD_array) :: DSHF_rv
        character(len=:), allocatable :: SHT_rv
        ! splicer begin namespace.example::nested.class.ExClass2.method.get_name3
        call c_exclass2_get_name3_bufferify(obj%cxxmem, DSHF_rv)
        allocate(character(len=DSHF_rv%elem_len):: SHT_rv)
        call SHROUD_copy_string_and_free(DSHF_rv, SHT_rv, DSHF_rv%elem_len)
        ! splicer end namespace.example::nested.class.ExClass2.method.get_name3
    end function exclass2_get_name3

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  string & getName4 +deref(allocatable)
    ! string & getName4 +deref(allocatable)
    ! Requested: f_string_scalar_result_allocatable
    ! Match:     f_string_result_allocatable
    ! Function:  void getName4
    ! Exact:     c_string_scalar_result_buf
    ! ----------------------------------------
    ! Argument:  string & SHF_rv +context(DSHF_rv)+deref(allocatable)+intent(out)
    ! Requested: f_string_&_result_allocatable
    ! Match:     f_string_result_allocatable
    ! Requested: c_string_&_result_buf_allocatable
    ! Match:     c_string_result_buf_allocatable
    function exclass2_get_name4(obj) &
            result(SHT_rv)
        class(exclass2) :: obj
        type(SHROUD_array) :: DSHF_rv
        character(len=:), allocatable :: SHT_rv
        ! splicer begin namespace.example::nested.class.ExClass2.method.get_name4
        call c_exclass2_get_name4_bufferify(obj%cxxmem, DSHF_rv)
        allocate(character(len=DSHF_rv%elem_len):: SHT_rv)
        call SHROUD_copy_string_and_free(DSHF_rv, SHT_rv, DSHF_rv%elem_len)
        ! splicer end namespace.example::nested.class.ExClass2.method.get_name4
    end function exclass2_get_name4

    ! ----------------------------------------
    ! Function:  int GetNameLength
    ! int GetNameLength
    ! Requested: f_native_scalar_result
    ! Match:     f_default
    ! Requested: c_native_scalar_result
    ! Match:     c_default
    !>
    !! \brief helper function for Fortran
    !!
    !<
    function exclass2_get_name_length(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        class(exclass2) :: obj
        integer(C_INT) :: SHT_rv
        ! splicer begin namespace.example::nested.class.ExClass2.method.get_name_length
        SHT_rv = c_exclass2_get_name_length(obj%cxxmem)
        ! splicer end namespace.example::nested.class.ExClass2.method.get_name_length
    end function exclass2_get_name_length

    ! ----------------------------------------
    ! Function:  ExClass1 * get_class1
    ! ExClass1 * get_class1
    ! Requested: f_shadow_*_result
    ! Match:     f_shadow_result
    ! Requested: c_shadow_*_result
    ! Match:     c_shadow_result
    ! ----------------------------------------
    ! Argument:  const ExClass1 * in +intent(in)
    ! Requested: f_shadow_*_in
    ! Match:     f_default
    ! Requested: c_shadow_*_in
    ! Match:     c_shadow_in
    function exclass2_get_class1(obj, in) &
            result(SHT_rv)
        use iso_c_binding, only : C_PTR
        class(exclass2) :: obj
        type(exclass1), intent(IN) :: in
        type(exclass1) :: SHT_rv
        ! splicer begin namespace.example::nested.class.ExClass2.method.get_class1
        type(C_PTR) :: SHT_prv
        SHT_prv = c_exclass2_get_class1(obj%cxxmem, in%cxxmem, &
            SHT_rv%cxxmem)
        ! splicer end namespace.example::nested.class.ExClass2.method.get_class1
    end function exclass2_get_class1

    ! Generated by fortran_generic - has_default_arg
    ! ----------------------------------------
    ! Function:  void * declare
    ! void * declare
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  TypeID type +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    subroutine exclass2_declare_0_int(obj, type)
        use iso_c_binding, only : C_INT
        class(exclass2) :: obj
        integer(C_INT), value, intent(IN) :: type
        ! splicer begin namespace.example::nested.class.ExClass2.method.declare_0_int
        call c_exclass2_declare_0(obj%cxxmem, type)
        ! splicer end namespace.example::nested.class.ExClass2.method.declare_0_int
    end subroutine exclass2_declare_0_int

    ! Generated by fortran_generic - has_default_arg
    ! ----------------------------------------
    ! Function:  void * declare
    ! void * declare
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  TypeID type +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    subroutine exclass2_declare_0_long(obj, type)
        use iso_c_binding, only : C_INT
        class(exclass2) :: obj
        integer(C_INT), value, intent(IN) :: type
        ! splicer begin namespace.example::nested.class.ExClass2.method.declare_0_long
        call c_exclass2_declare_0(obj%cxxmem, type)
        ! splicer end namespace.example::nested.class.ExClass2.method.declare_0_long
    end subroutine exclass2_declare_0_long

    ! Generated by fortran_generic
    ! ----------------------------------------
    ! Function:  void * declare
    ! void * declare
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  TypeID type +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int len=1 +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Argument:  SidreLength len=1 +intent(in)+value
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    subroutine exclass2_declare_1_int(obj, type, len)
        use iso_c_binding, only : C_INT, C_LONG
        class(exclass2) :: obj
        integer(C_INT), value, intent(IN) :: type
        integer(C_INT), value, intent(IN) :: len
        ! splicer begin namespace.example::nested.class.ExClass2.method.declare_1_int
        call c_exclass2_declare_1(obj%cxxmem, type, int(len, C_LONG))
        ! splicer end namespace.example::nested.class.ExClass2.method.declare_1_int
    end subroutine exclass2_declare_1_int

    ! Generated by fortran_generic
    ! ----------------------------------------
    ! Function:  void * declare
    ! void * declare
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  TypeID type +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  long len=1 +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Argument:  SidreLength len=1 +intent(in)+value
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    subroutine exclass2_declare_1_long(obj, type, len)
        use iso_c_binding, only : C_INT, C_LONG
        class(exclass2) :: obj
        integer(C_INT), value, intent(IN) :: type
        integer(C_LONG), value, intent(IN) :: len
        ! splicer begin namespace.example::nested.class.ExClass2.method.declare_1_long
        call c_exclass2_declare_1(obj%cxxmem, type, int(len, C_LONG))
        ! splicer end namespace.example::nested.class.ExClass2.method.declare_1_long
    end subroutine exclass2_declare_1_long

    ! ----------------------------------------
    ! Function:  void destroyall
    ! void destroyall
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    subroutine exclass2_destroyall(obj)
        class(exclass2) :: obj
        ! splicer begin namespace.example::nested.class.ExClass2.method.destroyall
        call c_exclass2_destroyall(obj%cxxmem)
        ! splicer end namespace.example::nested.class.ExClass2.method.destroyall
    end subroutine exclass2_destroyall

    ! ----------------------------------------
    ! Function:  TypeID getTypeID
    ! TypeID getTypeID
    ! Requested: f_native_scalar_result
    ! Match:     f_default
    ! Requested: c_native_scalar_result
    ! Match:     c_default
    function exclass2_get_type_id(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        class(exclass2) :: obj
        integer(C_INT) :: SHT_rv
        ! splicer begin namespace.example::nested.class.ExClass2.method.get_type_id
        SHT_rv = c_exclass2_get_type_id(obj%cxxmem)
        ! splicer end namespace.example::nested.class.ExClass2.method.get_type_id
    end function exclass2_get_type_id

    ! Generated by cxx_template
    ! ----------------------------------------
    ! Function:  void setValue
    ! void setValue
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int value +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    subroutine exclass2_set_value_int(obj, value)
        use iso_c_binding, only : C_INT
        class(exclass2) :: obj
        integer(C_INT), value, intent(IN) :: value
        ! splicer begin namespace.example::nested.class.ExClass2.method.set_value_int
        call c_exclass2_set_value_int(obj%cxxmem, value)
        ! splicer end namespace.example::nested.class.ExClass2.method.set_value_int
    end subroutine exclass2_set_value_int

    ! Generated by cxx_template
    ! ----------------------------------------
    ! Function:  void setValue
    ! void setValue
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  long value +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    subroutine exclass2_set_value_long(obj, value)
        use iso_c_binding, only : C_LONG
        class(exclass2) :: obj
        integer(C_LONG), value, intent(IN) :: value
        ! splicer begin namespace.example::nested.class.ExClass2.method.set_value_long
        call c_exclass2_set_value_long(obj%cxxmem, value)
        ! splicer end namespace.example::nested.class.ExClass2.method.set_value_long
    end subroutine exclass2_set_value_long

    ! Generated by cxx_template
    ! ----------------------------------------
    ! Function:  void setValue
    ! void setValue
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  float value +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    subroutine exclass2_set_value_float(obj, value)
        use iso_c_binding, only : C_FLOAT
        class(exclass2) :: obj
        real(C_FLOAT), value, intent(IN) :: value
        ! splicer begin namespace.example::nested.class.ExClass2.method.set_value_float
        call c_exclass2_set_value_float(obj%cxxmem, value)
        ! splicer end namespace.example::nested.class.ExClass2.method.set_value_float
    end subroutine exclass2_set_value_float

    ! Generated by cxx_template
    ! ----------------------------------------
    ! Function:  void setValue
    ! void setValue
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  double value +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    subroutine exclass2_set_value_double(obj, value)
        use iso_c_binding, only : C_DOUBLE
        class(exclass2) :: obj
        real(C_DOUBLE), value, intent(IN) :: value
        ! splicer begin namespace.example::nested.class.ExClass2.method.set_value_double
        call c_exclass2_set_value_double(obj%cxxmem, value)
        ! splicer end namespace.example::nested.class.ExClass2.method.set_value_double
    end subroutine exclass2_set_value_double

    ! Generated by cxx_template
    ! ----------------------------------------
    ! Function:  int getValue
    ! int getValue
    ! Requested: f_native_scalar_result
    ! Match:     f_default
    ! Requested: c_native_scalar_result
    ! Match:     c_default
    function exclass2_get_value_int(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        class(exclass2) :: obj
        integer(C_INT) :: SHT_rv
        ! splicer begin namespace.example::nested.class.ExClass2.method.get_value_int
        SHT_rv = c_exclass2_get_value_int(obj%cxxmem)
        ! splicer end namespace.example::nested.class.ExClass2.method.get_value_int
    end function exclass2_get_value_int

    ! Generated by cxx_template
    ! ----------------------------------------
    ! Function:  double getValue
    ! double getValue
    ! Requested: f_native_scalar_result
    ! Match:     f_default
    ! Requested: c_native_scalar_result
    ! Match:     c_default
    function exclass2_get_value_double(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE
        class(exclass2) :: obj
        real(C_DOUBLE) :: SHT_rv
        ! splicer begin namespace.example::nested.class.ExClass2.method.get_value_double
        SHT_rv = c_exclass2_get_value_double(obj%cxxmem)
        ! splicer end namespace.example::nested.class.ExClass2.method.get_value_double
    end function exclass2_get_value_double

    ! Return pointer to C++ memory.
    function exclass2_yadda(obj) result (cxxptr)
        use iso_c_binding, only: C_PTR
        class(exclass2), intent(IN) :: obj
        type(C_PTR) :: cxxptr
        cxxptr = obj%cxxmem%addr
    end function exclass2_yadda

    function exclass2_associated(obj) result (rv)
        use iso_c_binding, only: c_associated
        class(exclass2), intent(IN) :: obj
        logical rv
        rv = c_associated(obj%cxxmem%addr)
    end function exclass2_associated

    ! splicer begin namespace.example::nested.class.ExClass2.additional_functions
    ! splicer end namespace.example::nested.class.ExClass2.additional_functions

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  bool isNameValid
    ! bool isNameValid
    ! Requested: f_bool_scalar_result
    ! Match:     f_bool_result
    ! Requested: c_bool_scalar_result_buf
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const std::string & name +intent(in)
    ! Requested: f_string_&_in
    ! Match:     f_default
    ! Argument:  const std::string & name +intent(in)+len_trim(Lname)
    ! Requested: c_string_&_in_buf
    ! Match:     c_string_in_buf
    function is_name_valid(name) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL, C_INT
        character(len=*), intent(IN) :: name
        logical :: SHT_rv
        ! splicer begin namespace.example::nested.function.is_name_valid
        rv = name .ne. " "
        ! splicer end namespace.example::nested.function.is_name_valid
    end function is_name_valid

    ! ----------------------------------------
    ! Function:  bool isInitialized
    ! bool isInitialized
    ! Requested: f_bool_scalar_result
    ! Match:     f_bool_result
    ! Requested: c_bool_scalar_result
    ! Match:     c_default
    function is_initialized() &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL
        logical :: SHT_rv
        ! splicer begin namespace.example::nested.function.is_initialized
        SHT_rv = c_is_initialized()
        ! splicer end namespace.example::nested.function.is_initialized
    end function is_initialized

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void test_names
    ! void test_names
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const std::string & name +intent(in)
    ! Requested: f_string_&_in
    ! Match:     f_default
    ! Argument:  const std::string & name +intent(in)+len_trim(Lname)
    ! Requested: c_string_&_in_buf
    ! Match:     c_string_in_buf
    subroutine test_names(name)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: name
        ! splicer begin namespace.example::nested.function.test_names
        call c_test_names_bufferify(name, len_trim(name, kind=C_INT))
        ! splicer end namespace.example::nested.function.test_names
    end subroutine test_names

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void test_names
    ! void test_names
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const std::string & name +intent(in)
    ! Requested: f_string_&_in
    ! Match:     f_default
    ! Argument:  const std::string & name +intent(in)+len_trim(Lname)
    ! Requested: c_string_&_in_buf
    ! Match:     c_string_in_buf
    ! ----------------------------------------
    ! Argument:  int flag +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in_buf
    ! Match:     c_default
    subroutine test_names_flag(name, flag)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: name
        integer(C_INT), value, intent(IN) :: flag
        ! splicer begin namespace.example::nested.function.test_names_flag
        call c_test_names_flag_bufferify(name, &
            len_trim(name, kind=C_INT), flag)
        ! splicer end namespace.example::nested.function.test_names_flag
    end subroutine test_names_flag

    ! Generated by has_default_arg
    ! ----------------------------------------
    ! Function:  void testoptional
    ! void testoptional
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    subroutine testoptional_0()
        ! splicer begin namespace.example::nested.function.testoptional_0
        call c_testoptional_0()
        ! splicer end namespace.example::nested.function.testoptional_0
    end subroutine testoptional_0

    ! Generated by has_default_arg
    ! ----------------------------------------
    ! Function:  void testoptional
    ! void testoptional
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int i=1 +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    subroutine testoptional_1(i)
        use iso_c_binding, only : C_INT
        integer(C_INT), value, intent(IN) :: i
        ! splicer begin namespace.example::nested.function.testoptional_1
        call c_testoptional_1(i)
        ! splicer end namespace.example::nested.function.testoptional_1
    end subroutine testoptional_1

    ! ----------------------------------------
    ! Function:  void testoptional
    ! void testoptional
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int i=1 +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  long j=2 +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    subroutine testoptional_2(i, j)
        use iso_c_binding, only : C_INT, C_LONG
        integer(C_INT), value, intent(IN) :: i
        integer(C_LONG), value, intent(IN) :: j
        ! splicer begin namespace.example::nested.function.testoptional_2
        call c_testoptional_2(i, j)
        ! splicer end namespace.example::nested.function.testoptional_2
    end subroutine testoptional_2

#ifdef HAVE_MPI
    ! ----------------------------------------
    ! Function:  void testmpi
    ! void testmpi
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  MPI_Comm comm +intent(in)+value
    ! Requested: f_unknown_scalar_in
    ! Match:     f_default
    ! Requested: c_unknown_scalar_in
    ! Match:     c_default
    subroutine testmpi_mpi(comm)
        integer, value, intent(IN) :: comm
        ! splicer begin namespace.example::nested.function.testmpi_mpi
        call c_testmpi_mpi(comm)
        ! splicer end namespace.example::nested.function.testmpi_mpi
    end subroutine testmpi_mpi
#endif

#ifndef HAVE_MPI
    ! ----------------------------------------
    ! Function:  void testmpi
    ! void testmpi
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    subroutine testmpi_serial()
        ! splicer begin namespace.example::nested.function.testmpi_serial
        call c_testmpi_serial()
        ! splicer end namespace.example::nested.function.testmpi_serial
    end subroutine testmpi_serial
#endif

    ! ----------------------------------------
    ! Function:  void FuncPtr3
    ! void FuncPtr3
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    !>
    !! \brief abstract argument
    !!
    !<
    subroutine func_ptr3(get)
        procedure(func_ptr3_get) :: get
        ! splicer begin namespace.example::nested.function.func_ptr3
        call c_func_ptr3(get)
        ! splicer end namespace.example::nested.function.func_ptr3
    end subroutine func_ptr3

    ! ----------------------------------------
    ! Function:  void FuncPtr4
    ! void FuncPtr4
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    !>
    !! \brief abstract argument
    !!
    !<
    subroutine func_ptr4(get)
        procedure(custom_funptr) :: get
        ! splicer begin namespace.example::nested.function.func_ptr4
        call c_func_ptr4(get)
        ! splicer end namespace.example::nested.function.func_ptr4
    end subroutine func_ptr4

    ! ----------------------------------------
    ! Function:  void verylongfunctionname1
    ! void verylongfunctionname1
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int * verylongname1 +intent(inout)
    ! Requested: f_native_*_inout
    ! Match:     f_default
    ! Requested: c_native_*_inout
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int * verylongname2 +intent(inout)
    ! Requested: f_native_*_inout
    ! Match:     f_default
    ! Requested: c_native_*_inout
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int * verylongname3 +intent(inout)
    ! Requested: f_native_*_inout
    ! Match:     f_default
    ! Requested: c_native_*_inout
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int * verylongname4 +intent(inout)
    ! Requested: f_native_*_inout
    ! Match:     f_default
    ! Requested: c_native_*_inout
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int * verylongname5 +intent(inout)
    ! Requested: f_native_*_inout
    ! Match:     f_default
    ! Requested: c_native_*_inout
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int * verylongname6 +intent(inout)
    ! Requested: f_native_*_inout
    ! Match:     f_default
    ! Requested: c_native_*_inout
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int * verylongname7 +intent(inout)
    ! Requested: f_native_*_inout
    ! Match:     f_default
    ! Requested: c_native_*_inout
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int * verylongname8 +intent(inout)
    ! Requested: f_native_*_inout
    ! Match:     f_default
    ! Requested: c_native_*_inout
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int * verylongname9 +intent(inout)
    ! Requested: f_native_*_inout
    ! Match:     f_default
    ! Requested: c_native_*_inout
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int * verylongname10 +intent(inout)
    ! Requested: f_native_*_inout
    ! Match:     f_default
    ! Requested: c_native_*_inout
    ! Match:     c_default
    subroutine verylongfunctionname1(verylongname1, verylongname2, &
            verylongname3, verylongname4, verylongname5, verylongname6, &
            verylongname7, verylongname8, verylongname9, verylongname10)
        use iso_c_binding, only : C_INT
        integer(C_INT), intent(INOUT) :: verylongname1
        integer(C_INT), intent(INOUT) :: verylongname2
        integer(C_INT), intent(INOUT) :: verylongname3
        integer(C_INT), intent(INOUT) :: verylongname4
        integer(C_INT), intent(INOUT) :: verylongname5
        integer(C_INT), intent(INOUT) :: verylongname6
        integer(C_INT), intent(INOUT) :: verylongname7
        integer(C_INT), intent(INOUT) :: verylongname8
        integer(C_INT), intent(INOUT) :: verylongname9
        integer(C_INT), intent(INOUT) :: verylongname10
        ! splicer begin namespace.example::nested.function.verylongfunctionname1
        call c_verylongfunctionname1(verylongname1, verylongname2, &
            verylongname3, verylongname4, verylongname5, verylongname6, &
            verylongname7, verylongname8, verylongname9, verylongname10)
        ! splicer end namespace.example::nested.function.verylongfunctionname1
    end subroutine verylongfunctionname1

    ! ----------------------------------------
    ! Function:  int verylongfunctionname2
    ! int verylongfunctionname2
    ! Requested: f_native_scalar_result
    ! Match:     f_default
    ! Requested: c_native_scalar_result
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int verylongname1 +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int verylongname2 +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int verylongname3 +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int verylongname4 +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int verylongname5 +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int verylongname6 +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int verylongname7 +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int verylongname8 +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int verylongname9 +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int verylongname10 +intent(in)+value
    ! Requested: f_native_scalar_in
    ! Match:     f_default
    ! Requested: c_native_scalar_in
    ! Match:     c_default
    function verylongfunctionname2(verylongname1, verylongname2, &
            verylongname3, verylongname4, verylongname5, verylongname6, &
            verylongname7, verylongname8, verylongname9, verylongname10) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        integer(C_INT), value, intent(IN) :: verylongname1
        integer(C_INT), value, intent(IN) :: verylongname2
        integer(C_INT), value, intent(IN) :: verylongname3
        integer(C_INT), value, intent(IN) :: verylongname4
        integer(C_INT), value, intent(IN) :: verylongname5
        integer(C_INT), value, intent(IN) :: verylongname6
        integer(C_INT), value, intent(IN) :: verylongname7
        integer(C_INT), value, intent(IN) :: verylongname8
        integer(C_INT), value, intent(IN) :: verylongname9
        integer(C_INT), value, intent(IN) :: verylongname10
        integer(C_INT) :: SHT_rv
        ! splicer begin namespace.example::nested.function.verylongfunctionname2
        SHT_rv = c_verylongfunctionname2(verylongname1, verylongname2, &
            verylongname3, verylongname4, verylongname5, verylongname6, &
            verylongname7, verylongname8, verylongname9, verylongname10)
        ! splicer end namespace.example::nested.function.verylongfunctionname2
    end function verylongfunctionname2

    ! ----------------------------------------
    ! Function:  void cos_doubles
    ! void cos_doubles
    ! Requested: f_subroutine
    ! Match:     f_default
    ! Requested: c
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  double * in +intent(in)+rank(2)
    ! Requested: f_native_*_in
    ! Match:     f_default
    ! Requested: c_native_*_in
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  double * out +deref(allocatable)+dimension(shape(in))+intent(out)
    ! Exact:     f_native_*_out_allocatable
    ! Requested: c_native_*_out
    ! Match:     c_default
    !>
    !! \brief Test multidimensional arrays with allocatable
    !!
    !<
    subroutine cos_doubles(in, out)
        use iso_c_binding, only : C_DOUBLE, C_INT
        real(C_DOUBLE), intent(IN) :: in(:,:)
        real(C_DOUBLE), intent(OUT), allocatable :: out(:)
        integer(C_INT) :: SH_sizein
        ! splicer begin namespace.example::nested.function.cos_doubles
        allocate(out(shape(in)))
        SH_sizein = size(in,kind=C_INT)
        call c_cos_doubles(in, out, SH_sizein)
        ! splicer end namespace.example::nested.function.cos_doubles
    end subroutine cos_doubles

    ! splicer begin namespace.example::nested.additional_functions
    ! splicer end namespace.example::nested.additional_functions

    function exclass1_eq(a,b) result (rv)
        use iso_c_binding, only: c_associated
        type(exclass1), intent(IN) ::a,b
        logical :: rv
        if (c_associated(a%cxxmem%addr, b%cxxmem%addr)) then
            rv = .true.
        else
            rv = .false.
        endif
    end function exclass1_eq

    function exclass1_ne(a,b) result (rv)
        use iso_c_binding, only: c_associated
        type(exclass1), intent(IN) ::a,b
        logical :: rv
        if (.not. c_associated(a%cxxmem%addr, b%cxxmem%addr)) then
            rv = .true.
        else
            rv = .false.
        endif
    end function exclass1_ne

    function exclass2_eq(a,b) result (rv)
        use iso_c_binding, only: c_associated
        type(exclass2), intent(IN) ::a,b
        logical :: rv
        if (c_associated(a%cxxmem%addr, b%cxxmem%addr)) then
            rv = .true.
        else
            rv = .false.
        endif
    end function exclass2_eq

    function exclass2_ne(a,b) result (rv)
        use iso_c_binding, only: c_associated
        type(exclass2), intent(IN) ::a,b
        logical :: rv
        if (.not. c_associated(a%cxxmem%addr, b%cxxmem%addr)) then
            rv = .true.
        else
            rv = .false.
        endif
    end function exclass2_ne

end module userlibrary_example_nested_mod
