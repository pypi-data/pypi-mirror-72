/* This file was generated by PyBindGen 0.0.0.0 */
#define PY_SSIZE_T_CLEAN
#include <Python.h>
#include <stddef.h>


#if PY_VERSION_HEX < 0x020400F0

#define PyEval_ThreadsInitialized() 1

#define Py_CLEAR(op)				\
        do {                            	\
                if (op) {			\
                        PyObject *tmp = (PyObject *)(op);	\
                        (op) = NULL;		\
                        Py_DECREF(tmp);		\
                }				\
        } while (0)


#define Py_VISIT(op)							\
        do { 								\
                if (op) {						\
                        int vret = visit((PyObject *)(op), arg);	\
                        if (vret)					\
                                return vret;				\
                }							\
        } while (0)

#endif



#if PY_VERSION_HEX < 0x020500F0

typedef int Py_ssize_t;
# define PY_SSIZE_T_MAX INT_MAX
# define PY_SSIZE_T_MIN INT_MIN
typedef inquiry lenfunc;
typedef intargfunc ssizeargfunc;
typedef intobjargproc ssizeobjargproc;

#endif


#ifndef PyVarObject_HEAD_INIT
#define PyVarObject_HEAD_INIT(type, size) \
        PyObject_HEAD_INIT(type) size,
#endif


#if PY_VERSION_HEX >= 0x03000000
#if PY_VERSION_HEX >= 0x03050000
typedef PyAsyncMethods* cmpfunc;
#else
typedef void* cmpfunc;
#endif
#define PyCObject_FromVoidPtr(a, b) PyCapsule_New(a, NULL, b)
#define PyCObject_AsVoidPtr(a) PyCapsule_GetPointer(a, NULL)
#define PyString_FromString(a) PyBytes_FromString(a)
#define Py_TPFLAGS_CHECKTYPES 0 /* this flag doesn't exist in python 3 */
#endif


#if     __GNUC__ > 2
# define PYBINDGEN_UNUSED(param) param __attribute__((__unused__))
#elif     __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
# define PYBINDGEN_UNUSED(param) __attribute__((__unused__)) param
#else
# define PYBINDGEN_UNUSED(param) param
#endif  /* !__GNUC__ */

#ifndef _PyBindGenWrapperFlags_defined_
#define _PyBindGenWrapperFlags_defined_
typedef enum _PyBindGenWrapperFlags {
   PYBINDGEN_WRAPPER_FLAG_NONE = 0,
   PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED = (1<<0),
} PyBindGenWrapperFlags;
#endif


#include "tutorial.hpp"
/* --- module functions --- */


PyObject *
_wrap_tutorial_tutorial_UseDefaultArguments(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double retval;
    double arg1 = 3.1415;
    bool arg2;
    PyObject *py_arg2 = NULL;
    const char *keywords[] = {"arg1", "arg2", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|dO", (char **) keywords, &arg1, &py_arg2)) {
        return NULL;
    }
    arg2 = py_arg2? (bool) PyObject_IsTrue(py_arg2) : true;
    retval = tutorial::UseDefaultArguments(arg1, arg2);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}
PyObject * _wrap_tutorial_tutorial_UseDefaultArguments(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);



PyObject *
_wrap_tutorial_tutorial_OverloadedFunction__0(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *name = NULL;
    Py_ssize_t name_len;
    std::string name_std;
    const char *keywords[] = {"name", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &name, &name_len)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    name_std = std::string(name, name_len);
    tutorial::OverloadedFunction(name_std);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_tutorial_tutorial_OverloadedFunction__1(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    int index;
    const char *keywords[] = {"index", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &index)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    tutorial::OverloadedFunction(index);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_tutorial_tutorial_OverloadedFunction(PyObject *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_tutorial_tutorial_OverloadedFunction__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_tutorial_tutorial_OverloadedFunction__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}
PyObject * _wrap_tutorial_tutorial_OverloadedFunction(PyObject *self, PyObject *args, PyObject *kwargs);



PyObject *
_wrap_tutorial_tutorial_UseDefaultOverload__0(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    int retval;
    int num;
    int offset = 0;
    int stride = 1;
    const char *keywords[] = {"num", "offset", "stride", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i|ii", (char **) keywords, &num, &offset, &stride)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = tutorial::UseDefaultOverload(num, offset, stride);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

PyObject *
_wrap_tutorial_tutorial_UseDefaultOverload__1(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    int retval;
    double type;
    int num;
    int offset = 0;
    int stride = 1;
    const char *keywords[] = {"type", "num", "offset", "stride", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "di|ii", (char **) keywords, &type, &num, &offset, &stride)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = tutorial::UseDefaultOverload(type, num, offset, stride);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

PyObject * _wrap_tutorial_tutorial_UseDefaultOverload(PyObject *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_tutorial_tutorial_UseDefaultOverload__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_tutorial_tutorial_UseDefaultOverload__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}
PyObject * _wrap_tutorial_tutorial_UseDefaultOverload(PyObject *self, PyObject *args, PyObject *kwargs);

static PyMethodDef tutorial_tutorial_functions[] = {
    {(char *) "UseDefaultArguments", (PyCFunction) _wrap_tutorial_tutorial_UseDefaultArguments, METH_KEYWORDS|METH_VARARGS, "UseDefaultArguments(arg1, arg2)\n\ntype: arg1: double\ntype: arg2: bool" },
    {(char *) "OverloadedFunction", (PyCFunction) _wrap_tutorial_tutorial_OverloadedFunction, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "UseDefaultOverload", (PyCFunction) _wrap_tutorial_tutorial_UseDefaultOverload, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};
/* --- enumerations --- */



#if PY_VERSION_HEX >= 0x03000000
static struct PyModuleDef tutorial_tutorial_moduledef = {
    PyModuleDef_HEAD_INIT,
    "tutorial.tutorial",
    NULL,
    -1,
    tutorial_tutorial_functions,
};
#endif

static PyObject *
inittutorial_tutorial(void)
{
    PyObject *m;
    #if PY_VERSION_HEX >= 0x03000000
    m = PyModule_Create(&tutorial_tutorial_moduledef);
    #else
    m = Py_InitModule3((char *) "tutorial.tutorial", tutorial_tutorial_functions, NULL);
    #endif
    if (m == NULL) {
        return NULL;
    }
    PyModule_AddIntConstant(m, (char *) "RED", tutorial::RED);
    PyModule_AddIntConstant(m, (char *) "BLUE", tutorial::BLUE);
    PyModule_AddIntConstant(m, (char *) "WHITE", tutorial::WHITE);
    return m;
}
static PyMethodDef tutorial_functions[] = {
    {NULL, NULL, 0, NULL}
};
#if PY_VERSION_HEX >= 0x03000000
static struct PyModuleDef tutorial_moduledef = {
    PyModuleDef_HEAD_INIT,
    "tutorial",
    NULL,
    -1,
    tutorial_functions,
};
#endif


#if PY_VERSION_HEX >= 0x03000000
    #define MOD_ERROR NULL
    #define MOD_INIT(name) PyObject* PyInit_##name(void)
    #define MOD_RETURN(val) val
#else
    #define MOD_ERROR
    #define MOD_INIT(name) void init##name(void)
    #define MOD_RETURN(val)
#endif
#if defined(__cplusplus)
extern "C"
#endif
#if defined(__GNUC__) && __GNUC__ >= 4
__attribute__ ((visibility("default")))
#endif


MOD_INIT(tutorial)
{
    PyObject *m;
    PyObject *submodule;
    #if PY_VERSION_HEX >= 0x03000000
    m = PyModule_Create(&tutorial_moduledef);
    #else
    m = Py_InitModule3((char *) "tutorial", tutorial_functions, NULL);
    #endif
    if (m == NULL) {
        return MOD_ERROR;
    }
    submodule = inittutorial_tutorial();
    if (submodule == NULL) {
        return MOD_ERROR;
    }
    Py_INCREF(submodule);
    PyModule_AddObject(m, (char *) "tutorial", submodule);
    return MOD_RETURN(m);
}
