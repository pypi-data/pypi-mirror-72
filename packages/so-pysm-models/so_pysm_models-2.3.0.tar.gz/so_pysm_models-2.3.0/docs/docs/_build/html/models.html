
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Summary of Models &#8212; so_pysm_models v0.4.dev231</title>
    <link rel="stylesheet" href="_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <script type="text/javascript" src="_static/copybutton.js"></script>
    <link rel="shortcut icon" href="_static/astropy_logo.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="High resolution templates" href="highres_templates.html" />
    <link rel="prev" title="Getting started" href="gettingstarted.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="index.html"><span id="logotext1">so_pysm_models</span><span id="logotext2"></span><span id="logotext3">:docs</span></a>
  <ul>
    
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="genindex.html">Index</a></li>
    <li><a title="Module Index" href="py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li class="right">
	<a href="highres_templates.html" title="High resolution templates">
	  next &raquo;
	</a>
      </li>
      <li class="right">
	<a href="gettingstarted.html" title="Getting started">
	  &laquo; previous
	</a>
	 |
      </li>
      <li>
	<a href="index.html">so_pysm_models v0.4.dev231</a>
	 &#187;
      </li>
      
      <li>Summary of Models</li> 
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="summary-of-models">
<h1>Summary of Models<a class="headerlink" href="#summary-of-models" title="Permalink to this headline">¶</a></h1>
<p>This page contains high-level documentation about the available models,
check the classes doc strings, or the <a class="reference external" href="https://so-pysm-models.readthedocs.io/en/latest/so_pysm_models/index.html#classes">online documentation</a>, for the specific arguments.</p>
<p>The input template maps for many models are available at NERSC on the <code class="xref py py-obj docutils literal notranslate"><span class="pre">cmb</span></code> project space at:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="k">global</span><span class="o">/</span><span class="n">project</span><span class="o">/</span><span class="n">projectdirs</span><span class="o">/</span><span class="n">cmb</span><span class="o">/</span><span class="n">www</span><span class="o">/</span><span class="n">so_pysm_models_data</span>
</pre></div>
</div>
<p>they are also published via web at <a class="reference external" href="http://portal.nersc.gov/project/cmb/so_pysm_models_data/">http://portal.nersc.gov/project/cmb/so_pysm_models_data/</a>.</p>
<div class="section" id="gaussiansynchrotron">
<h2>GaussianSynchrotron<a class="headerlink" href="#gaussiansynchrotron" title="Permalink to this headline">¶</a></h2>
<p>This class implements Gaussian simulations for Galactic synchrotron emission.
The inputs are a bunch of parameters defining the properties of the synchrotron power spectra, and of synchrotron Spectral Energy Distribution (SED), the output are the stokes IQU maps simulated as Gaussian random fields of the defined spectra.
In particular, synchrotron power spectra <span class="math notranslate nohighlight">\(C_{\ell}\)</span> are assumed to follow a power law as a function of <span class="math notranslate nohighlight">\(\ell\)</span>: <span class="math notranslate nohighlight">\(C_{\ell}^{TT/TE/EE/BB}\propto\ell^{\alpha}\)</span>.
Spectra are defined by:</p>
<ol class="arabic simple">
<li><p>The slope <span class="math notranslate nohighlight">\(\alpha\)</span> (same for all the spectra)</p></li>
<li><p>The amplitude of TT and EE spectra at <span class="math notranslate nohighlight">\(\ell=80\)</span>,</p></li>
<li><p>The ratio between B and E-modes</p></li>
</ol>
<p>Stokes Q and U maps are generated as random realization of the polarization spectra. For the temperature map the situation is slightly different as we want the total intensity map to be positive everywhere.
The Stokes I map is generated in the following way:</p>
<dl class="simple">
<dt>if target <span class="math notranslate nohighlight">\(N_{side}&lt;=64\)</span>:</dt><dd><ol class="arabic simple">
<li><p>The TT power spectrum is  <span class="math notranslate nohighlight">\(C_\ell \propto \ell^\alpha\)</span> and <span class="math notranslate nohighlight">\(C_\ell[0]=0\)</span></p></li>
<li><p>A first temperature map T is generated as a gaussian realization of this power spectrum</p></li>
<li><p>A new map is obtained by adding to T an offset whose value is taken from a reference map</p></li>
<li><p>If T+offset is positive everywhere than this is the output temperature map</p></li>
<li><p>Otherwise a cut in the TT power spectrum is applied in the following way: <span class="math notranslate nohighlight">\(C_\ell[1:\ell_{cut}] = C_\ell[\ell_{cut}]\)</span></p></li>
<li><p>A new <span class="math notranslate nohighlight">\(T+offset\)</span> map is generated. The value of <span class="math notranslate nohighlight">\(\ell_{cut}\)</span> is the minimum one for which <span class="math notranslate nohighlight">\(T+offset\)</span> is positive everywhere</p></li>
</ol>
</dd>
<dt>if target <span class="math notranslate nohighlight">\(N_{side}&gt;64\)</span>:</dt><dd><ol class="arabic simple">
<li><p>a map at <span class="math notranslate nohighlight">\(N_{side}=64\)</span> is generated following the procedure above and then filtered to retain only large angular scales (ell&lt;30)</p></li>
<li><p>a map at the target <span class="math notranslate nohighlight">\(N_{side}\)</span> is generated including only small scales (ell&gt;30) with the same seed as the map at point 1.</p></li>
<li><p>the two maps are added together</p></li>
<li><p>In case the co-added map still has negative pixels a small offset is added to make it positive everywhere</p></li>
</ol>
</dd>
</dl>
<p>The default parameters are optimized for SO-SAT observations. Meaning that the amplitudes of power spectra are normalized in the 10% sky region observed by the instrument. In particular:</p>
<p>1. The amplitude of TT spectrum is taken from PySM-s0 model at 23GHz.  TT_amplitude = 20 <span class="math notranslate nohighlight">\(\mu K^2\)</span> (for <span class="math notranslate nohighlight">\(D_\ell\)</span> at <span class="math notranslate nohighlight">\(\ell=80\)</span>)
1. The offset for T map is also taken from PySM-s0 model at 23GHz.  Toffset = 72 <span class="math notranslate nohighlight">\(\mu K\)</span>
1. The amplitude of EE spectrum is taken from S-PASS at 2.3GHz extrapolated at 23GHz with a power-law with <span class="math notranslate nohighlight">\(\beta_s=-3.1\)</span> EE_amplitude = 4.3 math:<code class="xref py py-obj docutils literal notranslate"><span class="pre">mu</span> <span class="pre">K^2</span></code> (for <span class="math notranslate nohighlight">\(D_\ell\)</span> at <span class="math notranslate nohighlight">\(\ell=80\)</span>)
1. ratio between B and E modes from Krachmalnicoff et al. 2018, B_to_E = 0.5
1. spectral tilt from Krachmalnicoff et al 2018,  alpha = -1
1. spectral index from Planck IX 2018, beta = -3.1
1. Default value for curvature is zero</p>
</div>
<div class="section" id="gaussiandust">
<h2>GaussianDust<a class="headerlink" href="#gaussiandust" title="Permalink to this headline">¶</a></h2>
<p>This class implements Gaussian simulations for Galactic thermal dust emission.
The inputs are a bunch of parameters defining the properties of dust power spectra, and of dust Spectral Energy Distribution (SED), the output are the stokes IQU maps simulated as Gaussian random fields of the defined spectra.
In particular, dust power spectra <span class="math notranslate nohighlight">\(C_{\ell}\)</span> are assumed to follow a power law as a function of <span class="math notranslate nohighlight">\(\ell\)</span>: <span class="math notranslate nohighlight">\(C_{\ell}^{TT/TE/EE/BB}\propto\ell^{\alpha}\)</span>.
Spectra are defined by:</p>
<ol class="arabic simple">
<li><p>The slope <span class="math notranslate nohighlight">\(\alpha\)</span> (same for all the spectra)</p></li>
<li><p>The amplitude of TT and EE spectra at <span class="math notranslate nohighlight">\(\ell=80\)</span>,</p></li>
<li><p>The ratio between B and E-modes</p></li>
<li><p>The degree of correlation between T and E.</p></li>
</ol>
<p>Stokes Q and U maps are generated as random realization of the polarization spectra. For the temperature map the situation is slightly different as we want the total intensity map to be positive everywhere.
The Stokes I map is generated in the following way:</p>
<dl class="simple">
<dt>if target <span class="math notranslate nohighlight">\(N_{side}&lt;=64\)</span>:</dt><dd><ol class="arabic simple">
<li><p>The TT power spectrum is  <span class="math notranslate nohighlight">\(C_\ell \propto \ell^\alpha\)</span> and <span class="math notranslate nohighlight">\(C_\ell[0]=0\)</span></p></li>
<li><p>A first temperature map T is generated as a gaussian realization of this power spectrum</p></li>
<li><p>A new map is obtained by adding to T an offset whose value is taken from a reference map</p></li>
<li><p>If T+offset is positive everywhere than this is the output temperature map</p></li>
<li><p>Otherwise a cut in the TT power spectrum is applied in the following way: <span class="math notranslate nohighlight">\(C_\ell[1:\ell_{cut}] = C_\ell[\ell_{cut}]\)</span></p></li>
<li><p>A new <span class="math notranslate nohighlight">\(T+offset\)</span> map is generated. The value of <span class="math notranslate nohighlight">\(\ell_{cut}\)</span> is the minimum one for which <span class="math notranslate nohighlight">\(T+offset\)</span> is positive everywhere.</p></li>
</ol>
</dd>
<dt>if target <span class="math notranslate nohighlight">\(N_{side}&gt;64\)</span>:</dt><dd><ol class="arabic simple">
<li><p>a map at <span class="math notranslate nohighlight">\(N_{side}=64\)</span> is generated following the procedure above and then filtered to retain only large angular scales (ell&lt;30)</p></li>
<li><p>a map at the target <span class="math notranslate nohighlight">\(N_{side}\)</span> is generated including only small scales (ell&gt;30) with the same seed as the map at point 1.</p></li>
<li><p>the two maps are added together</p></li>
<li><p>In case the co-added map still has negative pixels a small offset is added to make it positive everywhere</p></li>
</ol>
</dd>
</dl>
<p>Typical values for <span class="math notranslate nohighlight">\(\ell_{cut}\)</span> are between <span class="math notranslate nohighlight">\(\ell=4\)</span> and <span class="math notranslate nohighlight">\(\ell=9\)</span>, depending on realization (and also on the <span class="math notranslate nohighlight">\(N_{side}\)</span> of the output map). This implementation removes some power at the very large scales.</p>
<p>The default parameters are optimized for SO-SAT observations. Meaning that the amplitudes of power spectra are normalized in the 10% sky region observed by the instrument. In particular:</p>
<ol class="arabic simple">
<li><p>The amplitude of TT spectrum is taken from PySM-d0 model at 353GHz.  TT_amplitude = 350 <span class="math notranslate nohighlight">\(\mu K^2\)</span> (for <span class="math notranslate nohighlight">\(D_\ell\)</span> at <span class="math notranslate nohighlight">\(\ell=80\)</span>)</p></li>
<li><p>The offset for T map is also taken from PySM-d0 model at 353GHz.  Toffset = 18 <span class="math notranslate nohighlight">\(\mu K\)</span></p></li>
<li><p>The amplitude of EE spectrum is taken from Planck map at 353GHz, EE_amplitude = 100 math:<code class="xref py py-obj docutils literal notranslate"><span class="pre">mu</span> <span class="pre">K^2</span></code> (for <span class="math notranslate nohighlight">\(D_\ell\)</span> at <span class="math notranslate nohighlight">\(\ell=80\)</span>)</p></li>
<li><p>ratio between B and E modes from Planck IX 2018, B_to_E = 0.5</p></li>
<li><p>spectral tilt from Planck IX 2018, alpha = -0.42</p></li>
<li><p>spectral index and temperature from Planck IX 2018, beta = 1.53, T=19.6 K</p></li>
</ol>
</div>
<div class="section" id="colines">
<h2>COLines<a class="headerlink" href="#colines" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="api/so_pysm_models.COLines.html#so_pysm_models.COLines" title="so_pysm_models.COLines"><code class="xref py py-class docutils literal notranslate"><span class="pre">COLines</span></code></a> is not a standard PySM component because PySM does not allow to distinguish between a case where a component is evaluated for the purpose of integrating over the bandpass or evaluated for separate channels.
Therefore this class should be instantiated choosing the desired line and summed to the output of PySM.
For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">so_pysm_models</span> <span class="k">import</span> <span class="n">COLines</span>
<span class="n">co</span> <span class="o">=</span> <span class="n">COLines</span><span class="p">(</span><span class="n">target_nside</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">output_units</span><span class="o">=</span><span class="s2">&quot;uK_CMB&quot;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="s2">&quot;10&quot;</span><span class="p">)</span>
<span class="n">pysm_map</span> <span class="o">+=</span> <span class="n">bandpass_weight</span> <span class="o">*</span> <span class="n">hp</span><span class="o">.</span><span class="n">smoothing</span><span class="p">(</span><span class="n">co</span><span class="o">.</span><span class="n">signal</span><span class="p">(),</span> <span class="n">fwhm</span><span class="o">=</span><span class="n">fwhm</span><span class="p">)</span>
</pre></div>
</div>
<p>Where <code class="xref py py-obj docutils literal notranslate"><span class="pre">bandpass_weight</span></code> is the scalar transmission at the line frequency (which is available at <code class="xref py py-obj docutils literal notranslate"><span class="pre">co.line_frequency</span></code>), i.e. if the bandpass is a top-hat between 110 and 120 GHz, the “10” line emission should be multiplied by <code class="xref py py-obj docutils literal notranslate"><span class="pre">0.1</span></code>.</p>
<p>This class implements simulations for Galactic CO emission involving the first 3 CO rotational lines, i.e. <span class="math notranslate nohighlight">\(J=1-0,2-1,3-2\)</span> whose center frequency is respectively at <span class="math notranslate nohighlight">\(\nu_0 = 115.3, 230.5,345.8\)</span> GHz. The CO emission map templates are the CO Planck maps obtained with <code class="docutils literal notranslate"><span class="pre">MILCA</span></code> component separation algorithm (See <code class="xref py py-obj docutils literal notranslate"><span class="pre">Planck</span> <span class="pre">paper</span></code>). The CO maps have been released at the nominal resolution (10 and 5 arcminutes). However, to reduce  noise contamination from template maps (especially at intermediate and high Galactic latitudes), we  convolved them with a 1 deg gaussian beam.</p>
<p>The Stokes I map is computed from the template one as it follows:</p>
<p>if target <span class="math notranslate nohighlight">\(N_{side}\)</span> &lt;= 512:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The template map at a <code class="docutils literal notranslate"><span class="pre">nside=512</span></code>  is downgraded at the target <span class="math notranslate nohighlight">\(N_{side}\)</span></p></li>
</ol>
</div></blockquote>
<p>if target <span class="math notranslate nohighlight">\(N_{side}\)</span> &gt; 512 :</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The template map at a <code class="docutils literal notranslate"><span class="pre">nside=2048</span></code>  is downgraded(eventually upgraded) at the target <span class="math notranslate nohighlight">\(N_{side}\)</span></p></li>
</ol>
</div></blockquote>
<p>Q and U maps can be computed from the template CO emission  map, <span class="math notranslate nohighlight">\(I_{CO}\)</span>,  assuming a constant  fractional polarization, as:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}Q = f_{pol} I_{CO}  g_d \cos( 2 \psi)\\U  = f_{pol} I_{CO}  g_d \sin( 2 \psi)\end{aligned}\end{align} \]</div>
<p>with <span class="math notranslate nohighlight">\(g_d\)</span> and <span class="math notranslate nohighlight">\(\psi\)</span> being respectively the depolarization and polarization angle maps estimated from a dust map as :</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}g_d = \frac{ \sqrt{Q^2_{d,353}    + U^2_{d,353}   } }{f_{pol} I_{d,353} }\\\psi = \frac{1}{2} \arctan {\frac{U_{d,353}}{Q_{d,353}}}\end{aligned}\end{align} \]</div>
<p>Most of the CO emission is expected to be confined in the  Galactic midplane. However, there are still regions at high Galactic latitudes  where the CO emission has been purely assessed (by current surveys) and where the Planck signal-to-noise was not enough to detect any emission.</p>
<p>The PySM user can include the eventuality of molecular emission (both unpolarized and polarized) at High Gal. Latitudes by co-adding to the emission maps one realization of CO emission simulated with MCMole3D together with  the Planck CO map. The polarization is simulated similarly as above.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">MCMole3D</span></code> input parameters  are are obtained from best fit with the Planck CO 1-0 map (see Puglisi et al. 2017 and the <code class="xref py py-obj docutils literal notranslate"><span class="pre">documentation</span></code>). If <code class="docutils literal notranslate"><span class="pre">include_high_galactic_latitude_clouds=True</span></code>, a mock CO cloud map is simulated with <code class="docutils literal notranslate"><span class="pre">MCMole3D</span></code>, encoding high Galactic latitudes clouds at latitudes above and below  than 20 degrees. The mock emission map is then co-added to the Planck CO emission map. The polarization is simulated similarly as above.</p>
<p>The installation of <code class="docutils literal notranslate"><span class="pre">mcmole3d</span></code> is not required, HGL clouds can be input to the CO emission by setting <code class="docutils literal notranslate"><span class="pre">run_mcmole3d=False</span></code>  (which is the default). However, if one wants to run several mock CO  realizations observing high Galactic latitude patches we encourage to run <code class="docutils literal notranslate"><span class="pre">mcmole3d</span></code> by changing <code class="docutils literal notranslate"><span class="pre">random_seed</span></code> in the CO class constructor. The parameter <code class="docutils literal notranslate"><span class="pre">theta_high_galactic_latitude_deg</span></code> set the latitude above which CO emission from high Galactic latitudes can be included and it has an impact <strong>only when</strong> <code class="docutils literal notranslate"><span class="pre">run_mcmole3d=True</span></code>.</p>
<p>The default parameters are set to include  CO 1-0 emission and polarization (with 0.1% constant polarization fraction), in particular:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">polarization_fraction=</span> <span class="pre">0.001</span></code>, on average is the expected level on 10% regions of the sky. However, polarization from CO emission have been detected at larger fluxes in  Orion and Taurus complexes (Greaves et al.1999 )</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">theta_high_galactic_latitude_deg</span> <span class="pre">=</span> <span class="pre">20</span></code>, includes CO emission at <span class="math notranslate nohighlight">\(|b|&gt;\theta_{hgl}\)</span> from one realization of mcmole3d maps. Be aware that the larger <span class="math notranslate nohighlight">\(theta_{hgl}\)</span>,  the farther is the  Galactic plane and  the more unlikely is to find high Galactic latitude clouds.</p></li>
</ol>
</div></blockquote>
</div>
<div class="section" id="precomputedalms">
<h2>PrecomputedAlms<a class="headerlink" href="#precomputedalms" title="Permalink to this headline">¶</a></h2>
<p>This class generates a PySM component based on a set of pre-computed <span class="math notranslate nohighlight">\(a_{\ell,m}\)</span> coefficients stored in a folder
in FITS format.
This is mostly targeted at simulations of the Cosmic Microwave Background, the input <span class="math notranslate nohighlight">\(a_{\ell,m}\)</span> can be in
<code class="xref py py-obj docutils literal notranslate"><span class="pre">K_{RJ}</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">K_{CMB}</span></code> as defined in the constructor, the unit conversion is performed assuming  the <code class="xref py py-obj docutils literal notranslate"><span class="pre">CMB</span></code> black body spectrum.
The output unit is specified in the <code class="xref py py-obj docutils literal notranslate"><span class="pre">signal</span></code> method, default is <code class="xref py py-obj docutils literal notranslate"><span class="pre">mu</span> <span class="pre">K_{RJ}</span></code>, as expected by <code class="xref py py-obj docutils literal notranslate"><span class="pre">PySM</span></code>.
In case the input is in <code class="xref py py-obj docutils literal notranslate"><span class="pre">K_{RJ}</span></code>, it is necessary also to specify <code class="xref py py-obj docutils literal notranslate"><span class="pre">input_reference_frequency_GHz</span></code>.</p>
<p>The transformation between Spherical Harmonics and pixel domain can be performed either during initialization or in the
<code class="xref py py-obj docutils literal notranslate"><span class="pre">signal</span></code> method based on <code class="xref py py-obj docutils literal notranslate"><span class="pre">precompute_output_map</span></code>.</p>
<p>See the <a class="reference external" href="https://mapsims.readthedocs.io">documentation about mapsims</a> about specific simulated datasets.</p>
</div>
<div class="section" id="interpolatingcomponent">
<h2>InterpolatingComponent<a class="headerlink" href="#interpolatingcomponent" title="Permalink to this headline">¶</a></h2>
<p><strong>Moved to PySM 3, FIXME port this documentation over</strong></p>
<p>Adds a custom emission to the sky simulated by PySM defined as a set of template maps at pre-defined frequencies to be interpolated at the frequencies requested through PySM.</p>
<p><strong>Inputs</strong></p>
<p>A folder of maps named with their frequency in GHz with the flux in any unit supported
by PySM (e.g. <code class="xref py py-obj docutils literal notranslate"><span class="pre">Jysr</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">MJsr</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">uK_RJ</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">K_CMB</span></code>).  They don’t need to be equally spaced</p>
<p>For example:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>ls <span class="sb">`</span>cib_precomputed_maps/<span class="sb">`</span>
<span class="m">0010</span>.0.fits <span class="m">0015</span>.0.fits <span class="m">0018</span>.0.fits
</pre></div>
</div>
<p><strong>Usage</strong></p>
<p>Instantiate <code class="xref py py-obj docutils literal notranslate"><span class="pre">InterpolatingComponent</span></code> and point it to the folder, define the unit and the target <span class="math notranslate nohighlight">\(N_{side}\)</span> (same used by PySM).
It supports all <code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolation_kind</span></code> of <code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.interpolate.interp1d()</span></code>, e.g. “nearest”, “linear”, “quadratic”, “cubic”:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">cib</span> <span class="o">=</span> <span class="n">InterpolatingComponent</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="s2">&quot;cib_precomputed_maps&quot;</span><span class="p">,</span> <span class="n">input_units</span><span class="o">=</span><span class="s2">&quot;MJysr&quot;</span><span class="p">,</span> <span class="n">target_nside</span><span class="o">=</span><span class="n">nside</span><span class="p">,</span> <span class="n">interpolation_kind</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                         <span class="n">has_polarization</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference external" href="https://gist.github.com/zonca/08751497b040ec9d62ff5175573c786e">Full example notebook</a></p>
</div>
<div class="section" id="websky">
<h2>WebSky<a class="headerlink" href="#websky" title="Permalink to this headline">¶</a></h2>
<p>The Websky suite of simulated extragalactic component maps, determined from large scale structure light cone realizations and  based on Lagrangian perturbation theory, Peak Patch Lagrangian halo finding, and modeling of SZ and CIB effects, can be read into PySM as precomputed external fits files using InterpolatingComponent.  More information on the Peak Patch halo finding method can be found in <a class="reference external" href="https://arxiv.org/abs/1810.07727">Stein, Alvarez, and Bond (2018)</a>, and selected maps and halo catalogs are available from the <a class="reference external" href="http://mocks.cita.utoronto.ca/websky">Websky website</a>. Some additional Websky-specific information and tools are available at the <a class="reference external" href="https://github.com/simonsobs/websky_model">SO Websky model repository</a>.</p>
<p>Specific maps generated for so_pysm_models are described below and located on NERSC at <code class="xref py py-obj docutils literal notranslate"><span class="pre">/project/projectdirs/sobs/v4_sims/mbs/websky/0.3</span></code>.</p>
<p><strong>Cosmic Infrared Background</strong></p>
<p>The Planck (2013) CIB halo model is used, along with a halo occupation distribution. More details can be found <a class="reference external" href="https://github.com/simonsobs/websky_model">here</a>.</p>
<p>The current version of the maps are of intensity in units of <span class="math notranslate nohighlight">\(MJy/Sr\)</span> with filename convention <code class="docutils literal notranslate"><span class="pre">cib_nu[FREQ].fits</span></code> e.g. <code class="docutils literal notranslate"><span class="pre">cib_nu0027.fits</span></code> is the map of CIB intensity at 27 GHz and will be used by <code class="xref py py-meth docutils literal notranslate"><span class="pre">InterpolatingComponent()</span></code> at that frequency, and can be found on NERSC at <code class="xref py py-obj docutils literal notranslate"><span class="pre">/project/projectdirs/sobs/v4_sims/mbs/websky/0.3</span></code>. There are 18 fits files at <span class="math notranslate nohighlight">\(N_{side}=4096\)</span> at frequencies [27, 39, 93, 145, 225, 280] +/- 1 GHz, in addition to those corresponding to the Planck HFI channel centers, [100, 143, 217, 353, 545, 857] GHz, for a total of 24 files. These intensities were selected because in order to be able to interpolate accurately at the 6 frequencies of interest with as few maps as possible. More frequencies will be made available after a full set of map based simulations at SO bands that include correlated lensing, CIB, and SZ effects has been generated.</p>
<p><strong>Thermal SZ Effect</strong></p>
<p>Provided is a map of the Compton-y parameter and is based on Battaglia et al. (2012) pressure profiles, and can be found at <code class="xref py py-obj docutils literal notranslate"><span class="pre">/project/projectdirs/sobs/v4_sims/mbs/websky/0.3/tsz.fits</span></code>.</p>
<p><strong>Kinetic SZ Effect</strong></p>
<p>Provided is a map of the temperature fluctuation due to line of sight peculiar velocities of electrons along the line of sight. Electrons are assumed to follow a Navarro Frenk and White (NFW) profile interior to halos and second order Lagrangian Perturbation Theory (LPT) outside. The ksz map can be found at <code class="xref py py-obj docutils literal notranslate"><span class="pre">/project/projectdirs/sobs/v4_sims/mbs/websky/0.3/ksz.fits</span></code>.</p>
<p><strong>Lensing Convergence</strong></p>
<p>A lensing convergence map is generated from the simulated matter distribution along the line of sight, assumed to follow an NFW profile interior to halos and second order LPT outside.</p>
<p><strong>Primary and lensed CMB</strong>
The convergence map is used to lens a Gaussian realization of the unlensed primary CMB, which is then read into PySM as the primary lensed CMB through the <a class="reference external" href="https://so-pysm-models.readthedocs.io/en/latest/api/so_pysm_models.PrecomputedAlms.html#so_pysm_models.PrecomputedAlms">PrecomputedAlms class</a>.
The primary CMB is obtained from parameters that match the Websky simulation, namely A_s = 2.022e-9, tau = 0.055, and all other parameters set to the websky values above.  The CAR maps (where the lens remapping is done) have 1 arcminute resolution.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>
<ul>
<li><a class="reference internal" href="#">Summary of Models</a><ul>
<li><a class="reference internal" href="#gaussiansynchrotron">GaussianSynchrotron</a></li>
<li><a class="reference internal" href="#gaussiandust">GaussianDust</a></li>
<li><a class="reference internal" href="#colines">COLines</a></li>
<li><a class="reference internal" href="#precomputedalms">PrecomputedAlms</a></li>
<li><a class="reference internal" href="#interpolatingcomponent">InterpolatingComponent</a></li>
<li><a class="reference internal" href="#websky">WebSky</a></li>
</ul>
</li>
</ul>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right">
    <a href="http://github.com/simonsobs/so_pysm_models/tree/master/docs/models.rst">Edit This Page on Github</a> &nbsp;
    <a href="_sources/models.rst.txt"
       rel="nofollow">Page Source</a> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2019, A. Zonca.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 2.0.1. &nbsp;
    Last built 04 Jun 2019. <br/>
  </p>
</footer>
  </body>
</html>