# coding: utf-8

"""
    Honeywell

    This is an api to connect to the Honeywell backend  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Contact: nick@aliroquantum.com
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

from aliro_honeywell.configuration import Configuration


class InlineResponse2001(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'job_response': 'JobResponse',
        'cost': 'int',
        'end_date': 'str',
        'name': 'str',
        'queue_position': 'int',
        'result_date': 'str',
        'results': 'dict(str, list[str])',
        'start_date': 'str',
        'submit_date': 'str',
        'websocket': 'object'
    }

    attribute_map = {
        'job_response': 'JobResponse',
        'cost': 'cost',
        'end_date': 'end-date',
        'name': 'name',
        'queue_position': 'queue-position',
        'result_date': 'result-date',
        'results': 'results',
        'start_date': 'start-date',
        'submit_date': 'submit-date',
        'websocket': 'websocket'
    }

    def __init__(self, job_response=None, cost=None, end_date=None, name=None, queue_position=None, result_date=None, results=None, start_date=None, submit_date=None, websocket=None, local_vars_configuration=None):  # noqa: E501
        """InlineResponse2001 - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._job_response = None
        self._cost = None
        self._end_date = None
        self._name = None
        self._queue_position = None
        self._result_date = None
        self._results = None
        self._start_date = None
        self._submit_date = None
        self._websocket = None
        self.discriminator = None

        if job_response is not None:
            self.job_response = job_response
        if cost is not None:
            self.cost = cost
        if end_date is not None:
            self.end_date = end_date
        if name is not None:
            self.name = name
        if queue_position is not None:
            self.queue_position = queue_position
        if result_date is not None:
            self.result_date = result_date
        if results is not None:
            self.results = results
        if start_date is not None:
            self.start_date = start_date
        self.submit_date = submit_date
        if websocket is not None:
            self.websocket = websocket

    @property
    def job_response(self):
        """Gets the job_response of this InlineResponse2001.  # noqa: E501


        :return: The job_response of this InlineResponse2001.  # noqa: E501
        :rtype: JobResponse
        """
        return self._job_response

    @job_response.setter
    def job_response(self, job_response):
        """Sets the job_response of this InlineResponse2001.


        :param job_response: The job_response of this InlineResponse2001.  # noqa: E501
        :type: JobResponse
        """

        self._job_response = job_response

    @property
    def cost(self):
        """Gets the cost of this InlineResponse2001.  # noqa: E501

        <cost> is the number of QCU estimated the job will consume or actually consumed if the job has already finished execution.  # noqa: E501

        :return: The cost of this InlineResponse2001.  # noqa: E501
        :rtype: int
        """
        return self._cost

    @cost.setter
    def cost(self, cost):
        """Sets the cost of this InlineResponse2001.

        <cost> is the number of QCU estimated the job will consume or actually consumed if the job has already finished execution.  # noqa: E501

        :param cost: The cost of this InlineResponse2001.  # noqa: E501
        :type: int
        """

        self._cost = cost

    @property
    def end_date(self):
        """Gets the end_date of this InlineResponse2001.  # noqa: E501

        <end-date> is the timestamp corresponding to job execution end. The timestamp is expressed in UTC with millisecond precision.  # noqa: E501

        :return: The end_date of this InlineResponse2001.  # noqa: E501
        :rtype: str
        """
        return self._end_date

    @end_date.setter
    def end_date(self, end_date):
        """Sets the end_date of this InlineResponse2001.

        <end-date> is the timestamp corresponding to job execution end. The timestamp is expressed in UTC with millisecond precision.  # noqa: E501

        :param end_date: The end_date of this InlineResponse2001.  # noqa: E501
        :type: str
        """

        self._end_date = end_date

    @property
    def name(self):
        """Gets the name of this InlineResponse2001.  # noqa: E501

        <job-name> is the user assigned job name.  # noqa: E501

        :return: The name of this InlineResponse2001.  # noqa: E501
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this InlineResponse2001.

        <job-name> is the user assigned job name.  # noqa: E501

        :param name: The name of this InlineResponse2001.  # noqa: E501
        :type: str
        """

        self._name = name

    @property
    def queue_position(self):
        """Gets the queue_position of this InlineResponse2001.  # noqa: E501

        <queue-position> number is returned when job status is \"queued\". Queue position indicates relative position of the job in a queue. When position reaches zero, job transitions from queued to running. The number normally decrements but can also increment for normal priority jobs when new high priority jobs are added.  # noqa: E501

        :return: The queue_position of this InlineResponse2001.  # noqa: E501
        :rtype: int
        """
        return self._queue_position

    @queue_position.setter
    def queue_position(self, queue_position):
        """Sets the queue_position of this InlineResponse2001.

        <queue-position> number is returned when job status is \"queued\". Queue position indicates relative position of the job in a queue. When position reaches zero, job transitions from queued to running. The number normally decrements but can also increment for normal priority jobs when new high priority jobs are added.  # noqa: E501

        :param queue_position: The queue_position of this InlineResponse2001.  # noqa: E501
        :type: int
        """

        self._queue_position = queue_position

    @property
    def result_date(self):
        """Gets the result_date of this InlineResponse2001.  # noqa: E501

        <result-date> is the timestamp corresponding to job final job result receipt. The timestamp is expressed in UTC with millisecond precision.  # noqa: E501

        :return: The result_date of this InlineResponse2001.  # noqa: E501
        :rtype: str
        """
        return self._result_date

    @result_date.setter
    def result_date(self, result_date):
        """Sets the result_date of this InlineResponse2001.

        <result-date> is the timestamp corresponding to job final job result receipt. The timestamp is expressed in UTC with millisecond precision.  # noqa: E501

        :param result_date: The result_date of this InlineResponse2001.  # noqa: E501
        :type: str
        """

        self._result_date = result_date

    @property
    def results(self):
        """Gets the results of this InlineResponse2001.  # noqa: E501

        <results> is a JSON-formatted array consisting of all classical measurements identified by the names of classical registers specified in the QASM source. Each classical register value is represented as a bitstring consisting of zeroes and ones. This field is only present if <job-status> is equal to \"completed\" or \"canceled\" with partial result set available. An example results parameter for a circuit with two classical registers c0 and c1 executed 8 times is shown below: \"results\": {   \"c0\": [\"00\", \"01\", \"01\", \"00\", \"10\", \"00\", \"00\", \"10\"],   \"c1\": [\"0010\", \"0110\", \"0011, \"0011\", \"1011\", \"0011\", \"0011\", \"0110\"] } The results are returned in the order of execution. First row corresponds to the first shot, second to the second shot, etc.The result is somewhat verbose since the measurement results for all shots are included as is. This approach enables any form of aggregation or statistical analysis on the raw measurement set since no information is lost between actual execution and the results delivered to end user. HTTP compression is recommended for larger results sets.   # noqa: E501

        :return: The results of this InlineResponse2001.  # noqa: E501
        :rtype: dict(str, list[str])
        """
        return self._results

    @results.setter
    def results(self, results):
        """Sets the results of this InlineResponse2001.

        <results> is a JSON-formatted array consisting of all classical measurements identified by the names of classical registers specified in the QASM source. Each classical register value is represented as a bitstring consisting of zeroes and ones. This field is only present if <job-status> is equal to \"completed\" or \"canceled\" with partial result set available. An example results parameter for a circuit with two classical registers c0 and c1 executed 8 times is shown below: \"results\": {   \"c0\": [\"00\", \"01\", \"01\", \"00\", \"10\", \"00\", \"00\", \"10\"],   \"c1\": [\"0010\", \"0110\", \"0011, \"0011\", \"1011\", \"0011\", \"0011\", \"0110\"] } The results are returned in the order of execution. First row corresponds to the first shot, second to the second shot, etc.The result is somewhat verbose since the measurement results for all shots are included as is. This approach enables any form of aggregation or statistical analysis on the raw measurement set since no information is lost between actual execution and the results delivered to end user. HTTP compression is recommended for larger results sets.   # noqa: E501

        :param results: The results of this InlineResponse2001.  # noqa: E501
        :type: dict(str, list[str])
        """

        self._results = results

    @property
    def start_date(self):
        """Gets the start_date of this InlineResponse2001.  # noqa: E501

        <start-date> is the timestamp corresponding to job execution start. The timestamp is expressed in UTC with millisecond precision.   # noqa: E501

        :return: The start_date of this InlineResponse2001.  # noqa: E501
        :rtype: str
        """
        return self._start_date

    @start_date.setter
    def start_date(self, start_date):
        """Sets the start_date of this InlineResponse2001.

        <start-date> is the timestamp corresponding to job execution start. The timestamp is expressed in UTC with millisecond precision.   # noqa: E501

        :param start_date: The start_date of this InlineResponse2001.  # noqa: E501
        :type: str
        """

        self._start_date = start_date

    @property
    def submit_date(self):
        """Gets the submit_date of this InlineResponse2001.  # noqa: E501

        <submit-date> is the timestamp corresponding to job submission. The timestamp is expressed in UTC with millisecond precision.   # noqa: E501

        :return: The submit_date of this InlineResponse2001.  # noqa: E501
        :rtype: str
        """
        return self._submit_date

    @submit_date.setter
    def submit_date(self, submit_date):
        """Sets the submit_date of this InlineResponse2001.

        <submit-date> is the timestamp corresponding to job submission. The timestamp is expressed in UTC with millisecond precision.   # noqa: E501

        :param submit_date: The submit_date of this InlineResponse2001.  # noqa: E501
        :type: str
        """
        if self.local_vars_configuration.client_side_validation and submit_date is None:  # noqa: E501
            raise ValueError("Invalid value for `submit_date`, must not be `None`")  # noqa: E501

        self._submit_date = submit_date

    @property
    def websocket(self):
        """Gets the websocket of this InlineResponse2001.  # noqa: E501

        <websocket> are necessary instructions to open a WebSocket to wait for job results. This allows users to avoid polling the system constantly for results. It is best practice to close the WebSocket after completion. This field only occurs if the query string parameter is included   # noqa: E501

        :return: The websocket of this InlineResponse2001.  # noqa: E501
        :rtype: object
        """
        return self._websocket

    @websocket.setter
    def websocket(self, websocket):
        """Sets the websocket of this InlineResponse2001.

        <websocket> are necessary instructions to open a WebSocket to wait for job results. This allows users to avoid polling the system constantly for results. It is best practice to close the WebSocket after completion. This field only occurs if the query string parameter is included   # noqa: E501

        :param websocket: The websocket of this InlineResponse2001.  # noqa: E501
        :type: object
        """

        self._websocket = websocket

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, InlineResponse2001):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, InlineResponse2001):
            return True

        return self.to_dict() != other.to_dict()
