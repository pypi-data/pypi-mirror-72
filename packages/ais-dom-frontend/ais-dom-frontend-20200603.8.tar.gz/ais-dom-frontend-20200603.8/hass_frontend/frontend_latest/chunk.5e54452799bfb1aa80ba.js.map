{"version":3,"file":"chunk.5e54452799bfb1aa80ba.js","sources":["webpack:///./node_modules/@polymer/paper-spinner/paper-spinner.js","webpack:///src/mwc-switch-base.ts","webpack:///./node_modules/@thomasloven/round-slider/src/main.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport '@polymer/paper-styles/color.js';\nimport './paper-spinner-styles.js';\n\nimport {Polymer} from '@polymer/polymer/lib/legacy/polymer-fn.js';\nimport {html} from '@polymer/polymer/lib/utils/html-tag.js';\n\nimport {PaperSpinnerBehavior} from './paper-spinner-behavior.js';\n\nconst template = html`\n  <style include=\"paper-spinner-styles\"></style>\n\n  <div id=\"spinnerContainer\" class-name=\"[[__computeContainerClasses(active, __coolingDown)]]\" on-animationend=\"__reset\" on-webkit-animation-end=\"__reset\">\n    <div class=\"spinner-layer layer-1\">\n      <div class=\"circle-clipper left\">\n        <div class=\"circle\"></div>\n      </div>\n      <div class=\"circle-clipper right\">\n        <div class=\"circle\"></div>\n      </div>\n    </div>\n\n    <div class=\"spinner-layer layer-2\">\n      <div class=\"circle-clipper left\">\n        <div class=\"circle\"></div>\n      </div>\n      <div class=\"circle-clipper right\">\n        <div class=\"circle\"></div>\n      </div>\n    </div>\n\n    <div class=\"spinner-layer layer-3\">\n      <div class=\"circle-clipper left\">\n        <div class=\"circle\"></div>\n      </div>\n      <div class=\"circle-clipper right\">\n        <div class=\"circle\"></div>\n      </div>\n    </div>\n\n    <div class=\"spinner-layer layer-4\">\n      <div class=\"circle-clipper left\">\n        <div class=\"circle\"></div>\n      </div>\n      <div class=\"circle-clipper right\">\n        <div class=\"circle\"></div>\n      </div>\n    </div>\n  </div>\n`;\ntemplate.setAttribute('strip-whitespace', '');\n\n/**\nMaterial design: [Progress &\nactivity](https://www.google.com/design/spec/components/progress-activity.html)\n\nElement providing a multiple color material design circular spinner.\n\n    <paper-spinner active></paper-spinner>\n\nThe default spinner cycles between four layers of colors; by default they are\nblue, red, yellow and green. It can be customized to cycle between four\ndifferent colors. Use <paper-spinner-lite> for single color spinners.\n\n### Accessibility\n\nAlt attribute should be set to provide adequate context for accessibility. If\nnot provided, it defaults to 'loading'. Empty alt can be provided to mark the\nelement as decorative if alternative content is provided in another form (e.g. a\ntext block following the spinner).\n\n    <paper-spinner alt=\"Loading contacts list\" active></paper-spinner>\n\n### Styling\n\nThe following custom properties and mixins are available for styling:\n\nCustom property | Description | Default\n----------------|-------------|----------\n`--paper-spinner-layer-1-color` | Color of the first spinner rotation | `--google-blue-500`\n`--paper-spinner-layer-2-color` | Color of the second spinner rotation | `--google-red-500`\n`--paper-spinner-layer-3-color` | Color of the third spinner rotation | `--google-yellow-500`\n`--paper-spinner-layer-4-color` | Color of the fourth spinner rotation | `--google-green-500`\n`--paper-spinner-stroke-width` | The width of the spinner stroke | 3px\n\n@group Paper Elements\n@element paper-spinner\n@hero hero.svg\n@demo demo/index.html\n*/\nPolymer({\n  _template: template,\n\n  is: 'paper-spinner',\n\n  behaviors: [PaperSpinnerBehavior]\n});\n","/**\n@license\nCopyright 2018 Google Inc. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport {addHasRemoveClass, FormElement, HTMLElementWithRipple} from '@material/mwc-base/form-element.js';\nimport {observer} from '@material/mwc-base/observer.js';\nimport {ripple} from '@material/mwc-ripple/ripple-directive.js';\nimport {MDCSwitchAdapter} from '@material/switch/adapter';\nimport MDCSwitchFoundation from '@material/switch/foundation.js';\nimport {html, property, query} from 'lit-element';\n\nexport class SwitchBase extends FormElement {\n  @property({type: Boolean})\n  @observer(function(this: SwitchBase, value: boolean) {\n    this.mdcFoundation.setChecked(value);\n  })\n  checked = false;\n\n  @property({type: Boolean})\n  @observer(function(this: SwitchBase, value: boolean) {\n    this.mdcFoundation.setDisabled(value);\n  })\n  disabled = false;\n\n  @query('.mdc-switch') protected mdcRoot!: HTMLElement;\n\n  @query('input') protected formElement!: HTMLInputElement;\n\n  protected mdcFoundation!: MDCSwitchFoundation;\n\n  private _changeHandler(e: Event) {\n    this.mdcFoundation.handleChange(e);\n    // catch \"click\" event and sync properties\n    this.checked = this.formElement.checked;\n  }\n\n  protected readonly mdcFoundationClass = MDCSwitchFoundation;\n\n  protected createAdapter(): MDCSwitchAdapter {\n    return {\n      ...addHasRemoveClass(this.mdcRoot),\n      setNativeControlChecked: (checked: boolean) => {\n        this.formElement.checked = checked;\n      },\n      setNativeControlDisabled: (disabled: boolean) => {\n        this.formElement.disabled = disabled;\n      },\n      setNativeControlAttr: (attr, value) => {\n        this.formElement.setAttribute(attr, value);\n      },\n    };\n  }\n\n  get ripple() {\n    return this.rippleNode.ripple;\n  }\n\n  @query('.mdc-switch__thumb-underlay')\n  protected rippleNode!: HTMLElementWithRipple;\n\n  protected render() {\n    return html`\n      <div class=\"mdc-switch\">\n        <div class=\"mdc-switch__track\"></div>\n        <div class=\"mdc-switch__thumb-underlay\" .ripple=\"${ripple({\n      interactionNode: this\n    })}\">\n          <div class=\"mdc-switch__thumb\">\n            <input\n              type=\"checkbox\"\n              id=\"basic-switch\"\n              class=\"mdc-switch__native-control\"\n              role=\"switch\"\n              @change=\"${this._changeHandler}\">\n          </div>\n        </div>\n      </div>`;\n  }\n}\n","import {\n  LitElement,\n  html,\n  css,\n  svg,\n} from \"lit-element\";\n\nclass RoundSlider extends LitElement {\n\n  static get properties() {\n    return {\n      value: {type: Number},\n      high: {type: Number},\n      low: {type: Number},\n      min: {type: Number},\n      max: {type: Number},\n      step: {type: Number},\n      startAngle: {type: Number},\n      arcLength: {type: Number},\n      handleSize: {type: Number},\n      handleZoom: {type: Number},\n      readonly: {type: Boolean},\n      disabled: {type: Boolean},\n      dragging: {type: Boolean, reflect: true},\n      rtl: {type: Boolean},\n      _scale: {type: Number},\n      valueLabel: {type: String},\n      lowLabel: {type: String},\n      highLabel: {type: String},\n    }\n  }\n\n  constructor() {\n    super();\n    this.min = 0;\n    this.max = 100;\n    this.step = 1;\n    this.startAngle = 135;\n    this.arcLength = 270;\n    this.handleSize = 6;\n    this.handleZoom = 1.5;\n    this.readonly = false;\n    this.disabled = false;\n    this.dragging = false;\n    this.rtl = false;\n    this._scale = 1;\n    this.attachedListeners = false;\n  }\n\n  get _start() {\n    return this.startAngle*Math.PI/180;\n  }\n  get _len() {\n    // Things get weird if length is more than a complete turn\n    return Math.min(this.arcLength*Math.PI/180, 2*Math.PI-0.01);\n  }\n  get _end() {\n    return this._start + this._len;\n  }\n\n  get _showHandle() {\n    // If handle is shown\n    if(this.readonly) return false;\n    if(this.value == null && (this.high == null || this.low == null)) return false;\n    return true;\n  }\n\n  _angleInside(angle) {\n    // Check if an angle is on the arc\n    let a = (this.startAngle + this.arcLength/2 - angle + 180 + 360) % 360 - 180;\n    return (a < this.arcLength/2 && a > -this.arcLength/2);\n  }\n  _angle2xy(angle) {\n    if(this.rtl)\n      return {x: -Math.cos(angle), y: Math.sin(angle)}\n    return {x: Math.cos(angle), y: Math.sin(angle)}\n  }\n  _xy2angle(x,y) {\n    if(this.rtl)\n      x = -x;\n    return (Math.atan2(y,x) - this._start + 2*Math.PI) % (2*Math.PI);\n  }\n\n  _value2angle(value) {\n    value = Math.min(this.max, Math.max(this.min, value));\n    const fraction = (value - this.min)/(this.max - this.min);\n    return this._start + fraction * this._len;\n  }\n  _angle2value(angle) {\n    return Math.round((angle/this._len*(this.max - this.min) + this.min)/this.step)*this.step;\n  }\n\n\n  get _boundaries() {\n    // Get the maximum extents of the bar arc\n    const start = this._angle2xy(this._start);\n    const end = this._angle2xy(this._end);\n\n    let up = 1;\n    if(!this._angleInside(270))\n      up =  Math.max(-start.y, -end.y);\n\n    let down = 1;\n    if(!this._angleInside(90))\n      down = Math.max(start.y, end.y);\n\n    let left = 1;\n    if(!this._angleInside(180))\n      left = Math.max(-start.x, -end.x);\n\n    let right = 1;\n    if(!this._angleInside(0))\n      right = Math.max(start.x, end.x);\n\n    return {\n      up, down, left, right,\n      height: up+down,\n      width: left+right,\n    };\n  }\n\n  _mouse2value(ev) {\n    const mouseX = (ev.type.startsWith(\"touch\")) ? ev.touches[0].clientX : ev.clientX;\n    const mouseY = (ev.type.startsWith(\"touch\")) ? ev.touches[0].clientY : ev.clientY;\n\n    const rect = this.shadowRoot.querySelector(\"svg\").getBoundingClientRect();\n    const boundaries = this._boundaries;\n    const x = mouseX - (rect.left + boundaries.left*rect.width/boundaries.width);\n    const y = mouseY - (rect.top + boundaries.up*rect.height/boundaries.height);\n\n    const angle = this._xy2angle(x,y);\n    const pos = this._angle2value(angle);\n    return pos;\n  }\n\n  dragStart(ev) {\n    if(!this._showHandle || this.disabled) return;\n    let handle = ev.target;\n    let cooldown = undefined;\n\n    // Avoid double events mouseDown->focus\n    if(this._rotation && this._rotation.type !== \"focus\") return;\n\n    // If the bar was touched, find the nearest handle and drag from that\n    if(handle.classList.contains(\"shadowpath\")) {\n      if(ev.type === \"touchstart\")\n        cooldown = window.setTimeout(() => {\n          if(this._rotation) this._rotation.cooldown = undefined;\n        }, 200);\n      if(this.low == null) {\n        handle = this.shadowRoot.querySelector(\"#value\");\n      } else {\n        const mouse = this._mouse2value(ev);\n        if(Math.abs(mouse-this.low) < Math.abs(mouse-this.high)) {\n          handle = this.shadowRoot.querySelector(\"#low\");\n        } else {\n          handle = this.shadowRoot.querySelector(\"#high\");\n        }\n      }\n    }\n\n    // If an invisible handle was clicked, switch to the visible counterpart\n    if(handle.classList.contains(\"overflow\"))\n      handle = handle.nextElementSibling;\n\n    if(!handle.classList.contains(\"handle\")) return;\n    handle.setAttribute('stroke-width', 2*this.handleSize*this.handleZoom*this._scale);\n\n    const min = handle.id === \"high\" ? this.low : this.min;\n    const max = handle.id === \"low\" ? this.high : this.max;\n    this._rotation = { handle, min, max, start: this[handle.id], type: ev.type, cooldown};\n    this.dragging = true;\n  }\n\n  _cleanupRotation() {\n    const handle = this._rotation.handle;\n    handle.setAttribute('stroke-width', 2*this.handleSize*this._scale);\n\n    this._rotation = false;\n    this.dragging = false;\n\n    handle.blur();\n  }\n\n  dragEnd(ev) {\n    if(!this._showHandle || this.disabled) return;\n    if(!this._rotation) return;\n\n    const handle = this._rotation.handle;\n    this._cleanupRotation();\n\n    let event = new CustomEvent('value-changed', {\n      detail: {\n        [handle.id] : this[handle.id],\n      }\n    });\n    this.dispatchEvent(event);\n\n    // This makes the low handle render over the high handle if they both are\n    // close to the top end.  Otherwise if would be unclickable, and the high\n    // handle locked by the low.  Calcualtion is done in the dragEnd handler to\n    // avoid \"z fighting\" while dragging.\n    if(this.low && this.low >= 0.99*this.max)\n      this._reverseOrder = true;\n    else\n      this._reverseOrder = false;\n  }\n\n  drag(ev) {\n    if(!this._showHandle || this.disabled) return;\n    if(!this._rotation) return;\n    if(this._rotation.cooldown) {\n      window.clearTimeout(this._rotation.coldown);\n      this._cleanupRotation()\n      return;\n    }\n    if(this._rotation.type === \"focus\") return;\n\n    ev.preventDefault();\n\n    const pos = this._mouse2value(ev);\n\n    this._dragpos(pos);\n  }\n\n  _dragpos(pos) {\n    if(pos < this._rotation.min || pos > this._rotation.max) return;\n\n    const handle = this._rotation.handle;\n    this[handle.id] = pos;\n\n    let event = new CustomEvent('value-changing', {\n      detail: {\n        [handle.id] : pos,\n      }\n    });\n    this.dispatchEvent(event);\n  }\n\n  _keyStep(ev) {\n    if(!this._showHandle || this.disabled) return;\n    if(!this._rotation) return;\n    const handle = this._rotation.handle;\n    if(ev.key === \"ArrowLeft\" || ev.key === \"ArrowDown\") {\n      ev.preventDefault();\n      if(this.rtl)\n        this._dragpos(this[handle.id] + this.step);\n      else\n        this._dragpos(this[handle.id] - this.step);\n    }\n    if(ev.key === \"ArrowRight\" || ev.key === \"ArrowUp\") {\n      ev.preventDefault();\n      if(this.rtl)\n        this._dragpos(this[handle.id] - this.step);\n      else\n        this._dragpos(this[handle.id] + this.step);\n    }\n    if(ev.key === \"Home\") {\n      ev.preventDefault();\n      this._dragpos(this.min);\n    }\n    if(ev.key === \"End\") {\n      ev.preventDefault();\n      this._dragpos(this.max);\n    }\n  }\n\n  firstUpdated() {\n    document.addEventListener('mouseup', this.dragEnd.bind(this));\n    document.addEventListener('touchend', this.dragEnd.bind(this), {passive: false});\n    document.addEventListener('mousemove', this.drag.bind(this));\n    document.addEventListener('touchmove', this.drag.bind(this), {passive: false});\n    document.addEventListener('keydown', this._keyStep.bind(this));\n  }\n\n  updated(changedProperties) {\n\n    // Adjust margin in the bar slider stroke width is greater than the handle size\n    if(this.shadowRoot.querySelector(\".slider\")) {\n      const styles = window.getComputedStyle(this.shadowRoot.querySelector(\".slider\"));\n      if (styles && styles['strokeWidth']) {\n        const stroke = parseFloat(styles['strokeWidth'])\n        if (stroke > this.handleSize*this.handleZoom) {\n          const view = this._boundaries;\n          const margin = `\n          ${stroke/2*Math.abs(view.up)}px\n          ${stroke/2*Math.abs(view.right)}px\n          ${stroke/2*Math.abs(view.down)}px\n          ${stroke/2*Math.abs(view.left)}px`;\n          this.shadowRoot.querySelector(\"svg\").style.margin = margin;\n        }\n      }\n    }\n\n    // Workaround for vector-effect not working in IE and pre-Chromium Edge\n    // That's also why the _scale property exists\n    if(this.shadowRoot.querySelector(\"svg\")\n    && this.shadowRoot.querySelector(\"svg\").style.vectorEffect === undefined) {\n      if(changedProperties.has(\"_scale\") && this._scale != 1) {\n        this.shadowRoot.querySelector(\"svg\").querySelectorAll(\"path\").forEach((e) => {\n          if(e.getAttribute('stroke-width')) return;\n          const orig = parseFloat(getComputedStyle(e).getPropertyValue('stroke-width'));\n          e.style.strokeWidth = `${orig*this._scale}px`;\n        });\n      }\n      const rect = this.shadowRoot.querySelector(\"svg\").getBoundingClientRect();\n      const scale = Math.max(rect.width, rect.height);\n      this._scale = 2/scale;\n    }\n\n  }\n\n  _renderArc(start, end) {\n    const diff = end-start;\n    start = this._angle2xy(start);\n    end = this._angle2xy(end+0.001); // Safari doesn't like arcs with no length\n    return `\n      M ${start.x} ${start.y}\n      A 1 1,\n        0,\n        ${(diff) > Math.PI ? \"1\" : \"0\"} ${this.rtl ? \"0\" : \"1\"},\n        ${end.x} ${end.y}\n    `;\n  }\n\n  _renderHandle(id) {\n    const theta = this._value2angle(this[id]);\n    const pos = this._angle2xy(theta);\n    const label = {\n      value: this.valueLabel,\n      low: this.lowLabel,\n      high: this.highLabel\n    }[id] || \"\";\n\n    // Two handles are drawn. One visible, and one invisible that's twice as\n    // big. Makes it easier to click.\n    return svg`\n      <g class=\"${id} handle\">\n        <path\n          id=${id}\n          class=\"overflow\"\n          d=\"\n          M ${pos.x} ${pos.y}\n          L ${pos.x+0.001} ${pos.y+0.001}\n          \"\n          vector-effect=\"non-scaling-stroke\"\n          stroke=\"rgba(0,0,0,0)\"\n          stroke-width=\"${4*this.handleSize*this._scale}\"\n          />\n        <path\n          id=${id}\n          class=\"handle\"\n          d=\"\n          M ${pos.x} ${pos.y}\n          L ${pos.x+0.001} ${pos.y+0.001}\n          \"\n          vector-effect=\"non-scaling-stroke\"\n          stroke-width=\"${2*this.handleSize*this._scale}\"\n          tabindex=\"0\"\n          @focus=${this.dragStart}\n          @blur=${this.dragEnd}\n          role=\"slider\"\n          aria-valuemin=${this.min}\n          aria-valuemax=${this.max}\n          aria-valuenow=${this[id]}\n          aria-disabled=${this.disabled}\n          aria-label=${label || \"\"}\n          />\n        </g>\n      `\n  };\n\n  render() {\n    const view = this._boundaries;\n\n    return html`\n      <svg\n        @mousedown=${this.dragStart}\n        @touchstart=${this.dragStart}\n        xmln=\"http://www.w3.org/2000/svg\"\n        viewBox=\"${-view.left} ${-view.up} ${view.width} ${view.height}\"\n        style=\"margin: ${this.handleSize*this.handleZoom}px;\"\n        ?disabled=${this.disabled}\n        focusable=\"false\"\n      >\n        <g class=\"slider\">\n          <path\n            class=\"path\"\n            d=${this._renderArc(this._start, this._end)}\n            vector-effect=\"non-scaling-stroke\"\n          />\n          <path\n            class=\"bar\"\n            vector-effect=\"non-scaling-stroke\"\n            d=${this._renderArc(\n              this._value2angle(this.low != null ? this.low : this.min),\n              this._value2angle(this.high != null ? this.high : this.value)\n            )}\n          />\n          <path\n            class=\"shadowpath\"\n            d=${this._renderArc(this._start, this._end)}\n            vector-effect=\"non-scaling-stroke\"\n            stroke=\"rgba(0,0,0,0)\"\n            stroke-width=\"${3*this.handleSize*this._scale}\"\n            stroke-linecap=\"butt\"\n          />\n\n        </g>\n\n        <g class=\"handles\">\n        ${ this._showHandle\n          ? this.low != null\n              ? this._reverseOrder\n                ? html`${this._renderHandle(\"high\")} ${this._renderHandle(\"low\")}`\n                : html`${this._renderHandle(\"low\")} ${this._renderHandle(\"high\")}`\n              : html`${this._renderHandle(\"value\")}`\n          : ``\n        }\n        </g>\n      </svg>\n    `;\n  }\n\n  static get styles() {\n    return css`\n      :host {\n        display: inline-block;\n        width: 100%;\n      }\n      svg {\n        overflow: visible;\n        display: block;\n      }\n      path {\n        transition: stroke 1s ease-out, stroke-width 200ms ease-out;\n      }\n      .slider {\n        fill: none;\n        stroke-width: var(--round-slider-path-width, 3);\n        stroke-linecap: var(--round-slider-linecap, round);\n      }\n      .path {\n        stroke: var(--round-slider-path-color, lightgray);\n      }\n      .bar {\n        stroke: var(--round-slider-bar-color, deepskyblue);\n      }\n      svg[disabled] .bar {\n        stroke: var(--round-slider-disabled-bar-color, darkgray);\n      }\n      g.handles {\n        stroke: var(--round-slider-handle-color, var(--round-slider-bar-color, deepskyblue));\n        stroke-linecap: round;\n      }\n      g.low.handle {\n        stroke: var(--round-slider-low-handle-color);\n      }\n      g.high.handle {\n        stroke: var(--round-slider-high-handle-color);\n      }\n      svg[disabled] g.handles {\n        stroke: var(--round-slider-disabled-bar-color, darkgray);\n      }\n      .handle:focus {\n        outline: unset;\n      }\n    `;\n  }\n\n}\ncustomElements.define('round-slider', RoundSlider);\n"],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4DA;;;ACgBA;;;;;;;AASA;;;AAzDA;ACqTA;;AAEA;;;AAGA;AACA;;;;AAIA;;;AAGA;;;AAGA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAMA;;AAKA;AACA;;AAEA;AACA;AACA;;;;;;AAMA;;;;;;AAMA;;;;AAOA;;;AAGA;;;;;;;AAOA;;;AAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A","sourceRoot":""}