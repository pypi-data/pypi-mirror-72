{"version":3,"file":"chunk.828912a74c312c4e7bed.js","sources":["webpack:///./node_modules/lit-virtualizer/lib/uni-virtualizer/lib/layouts/Layout1d.js"],"sourcesContent":["import { Layout1dBase } from './Layout1dBase.js';\nexport class Layout1d extends Layout1dBase {\n    constructor(config) {\n        super(config);\n        /**\n         * Indices of children mapped to their (position and length) in the scrolling\n         * direction. Used to keep track of children that are in range.\n         */\n        this._physicalItems = new Map();\n        /**\n         * Used in tandem with _physicalItems to track children in range across\n         * reflows.\n         */\n        this._newPhysicalItems = new Map();\n        /**\n         * Width and height of children by their index.\n         */\n        this._metrics = new Map();\n        /**\n         * anchorIdx is the anchor around which we reflow. It is designed to allow\n         * jumping to any point of the scroll size. We choose it once and stick with\n         * it until stable. _first and _last are deduced around it.\n         */\n        this._anchorIdx = null;\n        /**\n         * Position in the scrolling direction of the anchor child.\n         */\n        this._anchorPos = null;\n        /**\n         * Whether all children in range were in range during the previous reflow.\n         */\n        this._stable = true;\n        /**\n         * Whether to remeasure children during the next reflow.\n         */\n        this._needsRemeasure = false;\n        /**\n         * Number of children to lay out.\n         */\n        this._nMeasured = 0;\n        /**\n         * Total length in the scrolling direction of the laid out children.\n         */\n        this._tMeasured = 0;\n        this._estimate = true;\n    }\n    /**\n     * Determine the average size of all children represented in the sizes\n     * argument.\n     */\n    updateItemSizes(sizes) {\n        Object.keys(sizes).forEach((key) => {\n            const metrics = sizes[key], mi = this._getMetrics(Number(key)), prevSize = mi[this._sizeDim];\n            // TODO(valdrin) Handle margin collapsing.\n            // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing\n            mi.width = metrics.width + (metrics.marginLeft || 0) +\n                (metrics.marginRight || 0);\n            mi.height = metrics.height + (metrics.marginTop || 0) +\n                (metrics.marginBottom || 0);\n            const size = mi[this._sizeDim];\n            const item = this._getPhysicalItem(Number(key));\n            if (item) {\n                let delta;\n                if (size !== undefined) {\n                    item.size = size;\n                    if (prevSize === undefined) {\n                        delta = size;\n                        this._nMeasured++;\n                    }\n                    else {\n                        delta = size - prevSize;\n                    }\n                }\n                this._tMeasured = this._tMeasured + delta;\n            }\n        });\n        if (!this._nMeasured) {\n            console.warn(`No items measured yet.`);\n        }\n        else {\n            this._updateItemSize();\n            this._scheduleReflow();\n        }\n    }\n    /**\n     * Set the average item size based on the total length and number of children\n     * in range.\n     */\n    _updateItemSize() {\n        // Keep integer values.\n        this._itemSize[this._sizeDim] =\n            Math.round(this._tMeasured / this._nMeasured);\n    }\n    _getMetrics(idx) {\n        return (this._metrics[idx] = this._metrics[idx] || {});\n    }\n    _getPhysicalItem(idx) {\n        return this._newPhysicalItems.get(idx) || this._physicalItems.get(idx);\n    }\n    _getSize(idx) {\n        const item = this._getPhysicalItem(idx);\n        return item && item.size;\n    }\n    /**\n     * Returns the position in the scrolling direction of the item at idx.\n     * Estimates it if the item at idx is not in the DOM.\n     */\n    _getPosition(idx) {\n        const item = this._physicalItems.get(idx);\n        return item ? item.pos : (idx * (this._delta)) + this._spacing;\n    }\n    _calculateAnchor(lower, upper) {\n        if (lower === 0) {\n            return 0;\n        }\n        if (upper > this._scrollSize - this._viewDim1) {\n            return this._totalItems - 1;\n        }\n        return Math.max(0, Math.min(this._totalItems - 1, Math.floor(((lower + upper) / 2) / this._delta)));\n    }\n    _getAnchor(lower, upper) {\n        if (this._physicalItems.size === 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        if (this._first < 0) {\n            console.error('_getAnchor: negative _first');\n            return this._calculateAnchor(lower, upper);\n        }\n        if (this._last < 0) {\n            console.error('_getAnchor: negative _last');\n            return this._calculateAnchor(lower, upper);\n        }\n        const firstItem = this._getPhysicalItem(this._first), lastItem = this._getPhysicalItem(this._last), firstMin = firstItem.pos, firstMax = firstMin + firstItem.size, lastMin = lastItem.pos, lastMax = lastMin + lastItem.size;\n        if (lastMax < lower) {\n            // Window is entirely past physical items, calculate new anchor\n            return this._calculateAnchor(lower, upper);\n        }\n        if (firstMin > upper) {\n            // Window is entirely before physical items, calculate new anchor\n            return this._calculateAnchor(lower, upper);\n        }\n        if (firstMin >= lower || firstMax >= lower) {\n            // First physical item overlaps window, choose it\n            return this._first;\n        }\n        if (lastMax <= upper || lastMin <= upper) {\n            // Last physical overlaps window, choose it\n            return this._last;\n        }\n        // Window contains a physical item, but not the first or last\n        let maxIdx = this._last, minIdx = this._first;\n        while (true) {\n            const candidateIdx = Math.round((maxIdx + minIdx) / 2), candidate = this._physicalItems.get(candidateIdx), cMin = candidate.pos, cMax = cMin + candidate.size;\n            if ((cMin >= lower && cMin <= upper) ||\n                (cMax >= lower && cMax <= upper)) {\n                return candidateIdx;\n            }\n            else if (cMax < lower) {\n                minIdx = candidateIdx + 1;\n            }\n            else if (cMin > upper) {\n                maxIdx = candidateIdx - 1;\n            }\n        }\n    }\n    /**\n     * Updates _first and _last based on items that should be in the current\n     * viewed range.\n     */\n    _getActiveItems() {\n        if (this._viewDim1 === 0 || this._totalItems === 0) {\n            this._clearItems();\n        }\n        else {\n            const upper = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang), lower = Math.max(0, upper - this._viewDim1 - (2 * this._overhang));\n            this._getItems(lower, upper);\n        }\n    }\n    /**\n     * Sets the range to empty.\n     */\n    _clearItems() {\n        this._first = -1;\n        this._last = -1;\n        this._physicalMin = 0;\n        this._physicalMax = 0;\n        const items = this._newPhysicalItems;\n        this._newPhysicalItems = this._physicalItems;\n        this._newPhysicalItems.clear();\n        this._physicalItems = items;\n        this._stable = true;\n    }\n    /*\n     * Updates _first and _last based on items that should be in the given range.\n     */\n    _getItems(lower, upper) {\n        const items = this._newPhysicalItems;\n        // The anchorIdx is the anchor around which we reflow. It is designed to\n        // allow jumping to any point of the scroll size. We choose it once and\n        // stick with it until stable. first and last are deduced around it.\n        if (this._anchorIdx === null || this._anchorPos === null) {\n            this._anchorIdx = this._getAnchor(lower, upper);\n            this._anchorPos = this._getPosition(this._anchorIdx);\n        }\n        let anchorSize = this._getSize(this._anchorIdx);\n        if (anchorSize === undefined) {\n            anchorSize = this._itemDim1;\n        }\n        // Anchor might be outside bounds, so prefer correcting the error and keep\n        // that anchorIdx.\n        let anchorErr = 0;\n        if (this._anchorPos + anchorSize + this._spacing < lower) {\n            anchorErr = lower - (this._anchorPos + anchorSize + this._spacing);\n        }\n        if (this._anchorPos > upper) {\n            anchorErr = upper - this._anchorPos;\n        }\n        if (anchorErr) {\n            this._scrollPosition -= anchorErr;\n            lower -= anchorErr;\n            upper -= anchorErr;\n            this._scrollError += anchorErr;\n        }\n        // TODO @straversi: If size is always itemDim1, then why keep track of it?\n        items.set(this._anchorIdx, { pos: this._anchorPos, size: anchorSize });\n        this._first = (this._last = this._anchorIdx);\n        this._physicalMin = (this._physicalMax = this._anchorPos);\n        this._stable = true;\n        while (this._physicalMin > lower && this._first > 0) {\n            let size = this._getSize(--this._first);\n            if (size === undefined) {\n                this._stable = false;\n                size = this._itemDim1;\n            }\n            const pos = (this._physicalMin -= size + this._spacing);\n            items.set(this._first, { pos, size });\n            if (this._stable === false && this._estimate === false) {\n                break;\n            }\n        }\n        while (this._physicalMax < upper && this._last < this._totalItems) {\n            let size = this._getSize(this._last);\n            if (size === undefined) {\n                this._stable = false;\n                size = this._itemDim1;\n            }\n            items.set(this._last++, { pos: this._physicalMax, size });\n            if (this._stable === false && this._estimate === false) {\n                break;\n            }\n            else {\n                this._physicalMax += size + this._spacing;\n            }\n        }\n        this._last--;\n        // This handles the cases where we were relying on estimated sizes.\n        const extentErr = this._calculateError();\n        if (extentErr) {\n            this._physicalMin -= extentErr;\n            this._physicalMax -= extentErr;\n            this._anchorPos -= extentErr;\n            this._scrollPosition -= extentErr;\n            items.forEach((item) => item.pos -= extentErr);\n            this._scrollError += extentErr;\n        }\n        if (this._stable) {\n            this._newPhysicalItems = this._physicalItems;\n            this._newPhysicalItems.clear();\n            this._physicalItems = items;\n        }\n    }\n    _calculateError() {\n        if (this._first === 0) {\n            return this._physicalMin;\n        }\n        else if (this._physicalMin <= 0) {\n            return this._physicalMin - (this._first * this._delta);\n        }\n        else if (this._last === this._totalItems - 1) {\n            return this._physicalMax - this._scrollSize;\n        }\n        else if (this._physicalMax >= this._scrollSize) {\n            return ((this._physicalMax - this._scrollSize) +\n                ((this._totalItems - 1 - this._last) * this._delta));\n        }\n        return 0;\n    }\n    _updateScrollSize() {\n        // Reuse previously calculated physical max, as it might be higher than the\n        // estimated size.\n        super._updateScrollSize();\n        this._scrollSize = Math.max(this._physicalMax, this._scrollSize);\n    }\n    // TODO: Can this be made to inherit from base, with proper hooks?\n    _reflow() {\n        const { _first, _last, _scrollSize } = this;\n        this._updateScrollSize();\n        this._getActiveItems();\n        this._scrollIfNeeded();\n        if (this._scrollSize !== _scrollSize) {\n            this._emitScrollSize();\n        }\n        this._updateVisibleIndices();\n        this._emitRange();\n        if (this._first === -1 && this._last === -1) {\n            this._resetReflowState();\n        }\n        else if (this._first !== _first || this._last !== _last ||\n            this._needsRemeasure) {\n            this._emitChildPositions();\n            this._emitScrollError();\n        }\n        else {\n            this._emitChildPositions();\n            this._emitScrollError();\n            this._resetReflowState();\n        }\n    }\n    _resetReflowState() {\n        this._anchorIdx = null;\n        this._anchorPos = null;\n        this._stable = true;\n    }\n    /**\n     * Returns the top and left positioning of the item at idx.\n     */\n    _getItemPosition(idx) {\n        return {\n            [this._positionDim]: this._getPosition(idx),\n            [this._secondaryPositionDim]: 0,\n        };\n    }\n    /**\n     * Returns the height and width of the item at idx.\n     */\n    _getItemSize(idx) {\n        return {\n            [this._sizeDim]: this._getSize(idx) || this._itemDim1,\n            [this._secondarySizeDim]: this._itemDim2,\n        };\n    }\n    _viewDim2Changed() {\n        this._needsRemeasure = true;\n        this._scheduleReflow();\n    }\n    _emitRange() {\n        const remeasure = this._needsRemeasure;\n        const stable = this._stable;\n        this._needsRemeasure = false;\n        super._emitRange({ remeasure, stable });\n    }\n}\n"],"mappings":"AAAA","sourceRoot":""}