{"version":3,"file":"chunk.7445b08726dc08fa6096.js","sources":["webpack:///./src/resources/html-import/import-href.js"],"sourcesContent":["/* eslint-disable */\nimport \"./polyfill\";\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n// run a callback when HTMLImports are ready or immediately if\n// this api is not available.\nfunction whenImportsReady(cb) {\n  if (window.HTMLImports) {\n    HTMLImports.whenReady(cb);\n  } else {\n    cb();\n  }\n}\n\n/**\n * Convenience method for importing an HTML document imperatively.\n *\n * This method creates a new `<link rel=\"import\">` element with\n * the provided URL and appends it to the document to start loading.\n * In the `onload` callback, the `import` property of the `link`\n * element will contain the imported document contents.\n *\n * @param {string} href URL to document to load.\n * @param {?function(!Event):void=} onload Callback to notify when an import successfully\n *   loaded.\n * @param {?function(!ErrorEvent):void=} onerror Callback to notify when an import\n *   unsuccessfully loaded.\n * @param {boolean=} optAsync True if the import should be loaded `async`.\n *   Defaults to `false`.\n * @return {!HTMLLinkElement} The link element for the URL to be loaded.\n */\nexport const importHref = function (href, onload, onerror, optAsync) {\n  let link /** @type {HTMLLinkElement} */ = document.head.querySelector(\n    'link[href=\"' + href + '\"][import-href]'\n  );\n  if (!link) {\n    link = /** @type {HTMLLinkElement} */ (document.createElement(\"link\"));\n    link.rel = \"import\";\n    link.href = href;\n    link.setAttribute(\"import-href\", \"\");\n  }\n  // always ensure link has `async` attribute if user specified one,\n  // even if it was previously not async. This is considered less confusing.\n  if (optAsync) {\n    link.setAttribute(\"async\", \"\");\n  }\n  // NOTE: the link may now be in 3 states: (1) pending insertion,\n  // (2) inflight, (3) already loaded. In each case, we need to add\n  // event listeners to process callbacks.\n  const cleanup = function () {\n    link.removeEventListener(\"load\", loadListener);\n    link.removeEventListener(\"error\", errorListener);\n  };\n  let loadListener = function (event) {\n    cleanup();\n    // In case of a successful load, cache the load event on the link so\n    // that it can be used to short-circuit this method in the future when\n    // it is called with the same href param.\n    link.__dynamicImportLoaded = true;\n    if (onload) {\n      whenImportsReady(() => {\n        onload(event);\n      });\n    }\n  };\n  let errorListener = function (event) {\n    cleanup();\n    // In case of an error, remove the link from the document so that it\n    // will be automatically created again the next time `importHref` is\n    // called.\n    if (link.parentNode) {\n      link.parentNode.removeChild(link);\n    }\n    if (onerror) {\n      whenImportsReady(() => {\n        onerror(event);\n      });\n    }\n  };\n  link.addEventListener(\"load\", loadListener);\n  link.addEventListener(\"error\", errorListener);\n  if (link.parentNode == null) {\n    document.head.appendChild(link);\n    // if the link already loaded, dispatch a fake load event\n    // so that listeners are called and get a proper event argument.\n  } else if (link.__dynamicImportLoaded) {\n    link.dispatchEvent(new Event(\"load\"));\n  }\n  return link;\n};\n\nexport const importHrefPromise = (href) =>\n  new Promise((resolve, reject) => importHref(href, resolve, reject));\n"],"mappings":";AAAA","sourceRoot":""}