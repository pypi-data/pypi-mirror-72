{"version":3,"file":"chunk.6a90aaf9262b02d0bcd9.js","sources":["webpack:///./node_modules/@polymer/iron-fit-behavior/iron-fit-behavior.js","webpack:///./node_modules/@polymer/iron-overlay-behavior/iron-overlay-backdrop.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n\nimport {dom} from '@polymer/polymer/lib/legacy/polymer.dom.js';\n\n/**\n`Polymer.IronFitBehavior` fits an element in another element using `max-height`\nand `max-width`, and optionally centers it in the window or another element.\n\nThe element will only be sized and/or positioned if it has not already been\nsized and/or positioned by CSS.\n\nCSS properties            | Action\n--------------------------|-------------------------------------------\n`position` set            | Element is not centered horizontally or vertically\n`top` or `bottom` set     | Element is not vertically centered\n`left` or `right` set     | Element is not horizontally centered\n`max-height` set          | Element respects `max-height`\n`max-width` set           | Element respects `max-width`\n\n`Polymer.IronFitBehavior` can position an element into another element using\n`verticalAlign` and `horizontalAlign`. This will override the element's css\nposition.\n\n    <div class=\"container\">\n      <iron-fit-impl vertical-align=\"top\" horizontal-align=\"auto\">\n        Positioned into the container\n      </iron-fit-impl>\n    </div>\n\nUse `noOverlap` to position the element around another element without\noverlapping it.\n\n    <div class=\"container\">\n      <iron-fit-impl no-overlap vertical-align=\"auto\" horizontal-align=\"auto\">\n        Positioned around the container\n      </iron-fit-impl>\n    </div>\n\nUse `horizontalOffset, verticalOffset` to offset the element from its\n`positionTarget`; `Polymer.IronFitBehavior` will collapse these in order to\nkeep the element within `fitInto` boundaries, while preserving the element's\nCSS margin values.\n\n    <div class=\"container\">\n      <iron-fit-impl vertical-align=\"top\" vertical-offset=\"20\">\n        With vertical offset\n      </iron-fit-impl>\n    </div>\n\n@demo demo/index.html\n@polymerBehavior\n*/\nexport const IronFitBehavior = {\n\n  properties: {\n\n    /**\n     * The element that will receive a `max-height`/`width`. By default it is\n     * the same as `this`, but it can be set to a child element. This is useful,\n     * for example, for implementing a scrolling region inside the element.\n     * @type {!Element}\n     */\n    sizingTarget: {\n      type: Object,\n      value: function() {\n        return this;\n      }\n    },\n\n    /**\n     * The element to fit `this` into.\n     */\n    fitInto: {type: Object, value: window},\n\n    /**\n     * Will position the element around the positionTarget without overlapping\n     * it.\n     */\n    noOverlap: {type: Boolean},\n\n    /**\n     * The element that should be used to position the element. If not set, it\n     * will default to the parent node.\n     * @type {!Element}\n     */\n    positionTarget: {type: Element},\n\n    /**\n     * The orientation against which to align the element horizontally\n     * relative to the `positionTarget`. Possible values are \"left\", \"right\",\n     * \"center\", \"auto\".\n     */\n    horizontalAlign: {type: String},\n\n    /**\n     * The orientation against which to align the element vertically\n     * relative to the `positionTarget`. Possible values are \"top\", \"bottom\",\n     * \"middle\", \"auto\".\n     */\n    verticalAlign: {type: String},\n\n    /**\n     * If true, it will use `horizontalAlign` and `verticalAlign` values as\n     * preferred alignment and if there's not enough space, it will pick the\n     * values which minimize the cropping.\n     */\n    dynamicAlign: {type: Boolean},\n\n    /**\n     * A pixel value that will be added to the position calculated for the\n     * given `horizontalAlign`, in the direction of alignment. You can think\n     * of it as increasing or decreasing the distance to the side of the\n     * screen given by `horizontalAlign`.\n     *\n     * If `horizontalAlign` is \"left\" or \"center\", this offset will increase or\n     * decrease the distance to the left side of the screen: a negative offset\n     * will move the dropdown to the left; a positive one, to the right.\n     *\n     * Conversely if `horizontalAlign` is \"right\", this offset will increase\n     * or decrease the distance to the right side of the screen: a negative\n     * offset will move the dropdown to the right; a positive one, to the left.\n     */\n    horizontalOffset: {type: Number, value: 0, notify: true},\n\n    /**\n     * A pixel value that will be added to the position calculated for the\n     * given `verticalAlign`, in the direction of alignment. You can think\n     * of it as increasing or decreasing the distance to the side of the\n     * screen given by `verticalAlign`.\n     *\n     * If `verticalAlign` is \"top\" or \"middle\", this offset will increase or\n     * decrease the distance to the top side of the screen: a negative offset\n     * will move the dropdown upwards; a positive one, downwards.\n     *\n     * Conversely if `verticalAlign` is \"bottom\", this offset will increase\n     * or decrease the distance to the bottom side of the screen: a negative\n     * offset will move the dropdown downwards; a positive one, upwards.\n     */\n    verticalOffset: {type: Number, value: 0, notify: true},\n\n    /**\n     * Set to true to auto-fit on attach.\n     */\n    autoFitOnAttach: {type: Boolean, value: false},\n\n    /** @type {?Object} */\n    _fitInfo: {type: Object}\n  },\n\n  get _fitWidth() {\n    var fitWidth;\n    if (this.fitInto === window) {\n      fitWidth = this.fitInto.innerWidth;\n    } else {\n      fitWidth = this.fitInto.getBoundingClientRect().width;\n    }\n    return fitWidth;\n  },\n\n  get _fitHeight() {\n    var fitHeight;\n    if (this.fitInto === window) {\n      fitHeight = this.fitInto.innerHeight;\n    } else {\n      fitHeight = this.fitInto.getBoundingClientRect().height;\n    }\n    return fitHeight;\n  },\n\n  get _fitLeft() {\n    var fitLeft;\n    if (this.fitInto === window) {\n      fitLeft = 0;\n    } else {\n      fitLeft = this.fitInto.getBoundingClientRect().left;\n    }\n    return fitLeft;\n  },\n\n  get _fitTop() {\n    var fitTop;\n    if (this.fitInto === window) {\n      fitTop = 0;\n    } else {\n      fitTop = this.fitInto.getBoundingClientRect().top;\n    }\n    return fitTop;\n  },\n\n  /**\n   * The element that should be used to position the element,\n   * if no position target is configured.\n   */\n  get _defaultPositionTarget() {\n    var parent = dom(this).parentNode;\n\n    if (parent && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      parent = parent.host;\n    }\n\n    return parent;\n  },\n\n  /**\n   * The horizontal align value, accounting for the RTL/LTR text direction.\n   */\n  get _localeHorizontalAlign() {\n    if (this._isRTL) {\n      // In RTL, \"left\" becomes \"right\".\n      if (this.horizontalAlign === 'right') {\n        return 'left';\n      }\n      if (this.horizontalAlign === 'left') {\n        return 'right';\n      }\n    }\n    return this.horizontalAlign;\n  },\n\n  /**\n   * True if the element should be positioned instead of centered.\n   * @private\n   */\n  get __shouldPosition() {\n    return (this.horizontalAlign || this.verticalAlign) && this.positionTarget;\n  },\n\n  attached: function() {\n    // Memoize this to avoid expensive calculations & relayouts.\n    // Make sure we do it only once\n    if (typeof this._isRTL === 'undefined') {\n      this._isRTL = window.getComputedStyle(this).direction == 'rtl';\n    }\n    this.positionTarget = this.positionTarget || this._defaultPositionTarget;\n    if (this.autoFitOnAttach) {\n      if (window.getComputedStyle(this).display === 'none') {\n        setTimeout(function() {\n          this.fit();\n        }.bind(this));\n      } else {\n        // NOTE: shadydom applies distribution asynchronously\n        // for performance reasons webcomponents/shadydom#120\n        // Flush to get correct layout info.\n        window.ShadyDOM && ShadyDOM.flush();\n        this.fit();\n      }\n    }\n  },\n\n  detached: function() {\n    if (this.__deferredFit) {\n      clearTimeout(this.__deferredFit);\n      this.__deferredFit = null;\n    }\n  },\n\n  /**\n   * Positions and fits the element into the `fitInto` element.\n   */\n  fit: function() {\n    this.position();\n    this.constrain();\n    this.center();\n  },\n\n  /**\n   * Memoize information needed to position and size the target element.\n   * @suppress {deprecated}\n   */\n  _discoverInfo: function() {\n    if (this._fitInfo) {\n      return;\n    }\n    var target = window.getComputedStyle(this);\n    var sizer = window.getComputedStyle(this.sizingTarget);\n\n    this._fitInfo = {\n      inlineStyle: {\n        top: this.style.top || '',\n        left: this.style.left || '',\n        position: this.style.position || ''\n      },\n      sizerInlineStyle: {\n        maxWidth: this.sizingTarget.style.maxWidth || '',\n        maxHeight: this.sizingTarget.style.maxHeight || '',\n        boxSizing: this.sizingTarget.style.boxSizing || ''\n      },\n      positionedBy: {\n        vertically: target.top !== 'auto' ?\n            'top' :\n            (target.bottom !== 'auto' ? 'bottom' : null),\n        horizontally: target.left !== 'auto' ?\n            'left' :\n            (target.right !== 'auto' ? 'right' : null)\n      },\n      sizedBy: {\n        height: sizer.maxHeight !== 'none',\n        width: sizer.maxWidth !== 'none',\n        minWidth: parseInt(sizer.minWidth, 10) || 0,\n        minHeight: parseInt(sizer.minHeight, 10) || 0\n      },\n      margin: {\n        top: parseInt(target.marginTop, 10) || 0,\n        right: parseInt(target.marginRight, 10) || 0,\n        bottom: parseInt(target.marginBottom, 10) || 0,\n        left: parseInt(target.marginLeft, 10) || 0\n      }\n    };\n  },\n\n  /**\n   * Resets the target element's position and size constraints, and clear\n   * the memoized data.\n   */\n  resetFit: function() {\n    var info = this._fitInfo || {};\n    for (var property in info.sizerInlineStyle) {\n      this.sizingTarget.style[property] = info.sizerInlineStyle[property];\n    }\n    for (var property in info.inlineStyle) {\n      this.style[property] = info.inlineStyle[property];\n    }\n\n    this._fitInfo = null;\n  },\n\n  /**\n   * Equivalent to calling `resetFit()` and `fit()`. Useful to call this after\n   * the element or the `fitInto` element has been resized, or if any of the\n   * positioning properties (e.g. `horizontalAlign, verticalAlign`) is updated.\n   * It preserves the scroll position of the sizingTarget.\n   */\n  refit: function() {\n    var scrollLeft = this.sizingTarget.scrollLeft;\n    var scrollTop = this.sizingTarget.scrollTop;\n    this.resetFit();\n    this.fit();\n    this.sizingTarget.scrollLeft = scrollLeft;\n    this.sizingTarget.scrollTop = scrollTop;\n  },\n\n  /**\n   * Positions the element according to `horizontalAlign, verticalAlign`.\n   */\n  position: function() {\n    if (!this.__shouldPosition) {\n      // needs to be centered, and it is done after constrain.\n      return;\n    }\n    this._discoverInfo();\n\n    this.style.position = 'fixed';\n    // Need border-box for margin/padding.\n    this.sizingTarget.style.boxSizing = 'border-box';\n    // Set to 0, 0 in order to discover any offset caused by parent stacking\n    // contexts.\n    this.style.left = '0px';\n    this.style.top = '0px';\n\n    var rect = this.getBoundingClientRect();\n    var positionRect = this.__getNormalizedRect(this.positionTarget);\n    var fitRect = this.__getNormalizedRect(this.fitInto);\n\n    var margin = this._fitInfo.margin;\n\n    // Consider the margin as part of the size for position calculations.\n    var size = {\n      width: rect.width + margin.left + margin.right,\n      height: rect.height + margin.top + margin.bottom\n    };\n\n    var position = this.__getPosition(\n        this._localeHorizontalAlign,\n        this.verticalAlign,\n        size,\n        rect,\n        positionRect,\n        fitRect);\n\n    var left = position.left + margin.left;\n    var top = position.top + margin.top;\n\n    // We first limit right/bottom within fitInto respecting the margin,\n    // then use those values to limit top/left.\n    var right = Math.min(fitRect.right - margin.right, left + rect.width);\n    var bottom = Math.min(fitRect.bottom - margin.bottom, top + rect.height);\n\n    // Keep left/top within fitInto respecting the margin.\n    left = Math.max(\n        fitRect.left + margin.left,\n        Math.min(left, right - this._fitInfo.sizedBy.minWidth));\n    top = Math.max(\n        fitRect.top + margin.top,\n        Math.min(top, bottom - this._fitInfo.sizedBy.minHeight));\n\n    // Use right/bottom to set maxWidth/maxHeight, and respect\n    // minWidth/minHeight.\n    this.sizingTarget.style.maxWidth =\n        Math.max(right - left, this._fitInfo.sizedBy.minWidth) + 'px';\n    this.sizingTarget.style.maxHeight =\n        Math.max(bottom - top, this._fitInfo.sizedBy.minHeight) + 'px';\n\n    // Remove the offset caused by any stacking context.\n    this.style.left = (left - rect.left) + 'px';\n    this.style.top = (top - rect.top) + 'px';\n  },\n\n  /**\n   * Constrains the size of the element to `fitInto` by setting `max-height`\n   * and/or `max-width`.\n   */\n  constrain: function() {\n    if (this.__shouldPosition) {\n      return;\n    }\n    this._discoverInfo();\n\n    var info = this._fitInfo;\n    // position at (0px, 0px) if not already positioned, so we can measure the\n    // natural size.\n    if (!info.positionedBy.vertically) {\n      this.style.position = 'fixed';\n      this.style.top = '0px';\n    }\n    if (!info.positionedBy.horizontally) {\n      this.style.position = 'fixed';\n      this.style.left = '0px';\n    }\n\n    // need border-box for margin/padding\n    this.sizingTarget.style.boxSizing = 'border-box';\n    // constrain the width and height if not already set\n    var rect = this.getBoundingClientRect();\n    if (!info.sizedBy.height) {\n      this.__sizeDimension(\n          rect, info.positionedBy.vertically, 'top', 'bottom', 'Height');\n    }\n    if (!info.sizedBy.width) {\n      this.__sizeDimension(\n          rect, info.positionedBy.horizontally, 'left', 'right', 'Width');\n    }\n  },\n\n  /**\n   * @protected\n   * @deprecated\n   */\n  _sizeDimension: function(rect, positionedBy, start, end, extent) {\n    this.__sizeDimension(rect, positionedBy, start, end, extent);\n  },\n\n  /**\n   * @private\n   */\n  __sizeDimension: function(rect, positionedBy, start, end, extent) {\n    var info = this._fitInfo;\n    var fitRect = this.__getNormalizedRect(this.fitInto);\n    var max = extent === 'Width' ? fitRect.width : fitRect.height;\n    var flip = (positionedBy === end);\n    var offset = flip ? max - rect[end] : rect[start];\n    var margin = info.margin[flip ? start : end];\n    var offsetExtent = 'offset' + extent;\n    var sizingOffset = this[offsetExtent] - this.sizingTarget[offsetExtent];\n    this.sizingTarget.style['max' + extent] =\n        (max - margin - offset - sizingOffset) + 'px';\n  },\n\n  /**\n   * Centers horizontally and vertically if not already positioned. This also\n   * sets `position:fixed`.\n   */\n  center: function() {\n    if (this.__shouldPosition) {\n      return;\n    }\n    this._discoverInfo();\n\n    var positionedBy = this._fitInfo.positionedBy;\n    if (positionedBy.vertically && positionedBy.horizontally) {\n      // Already positioned.\n      return;\n    }\n    // Need position:fixed to center\n    this.style.position = 'fixed';\n    // Take into account the offset caused by parents that create stacking\n    // contexts (e.g. with transform: translate3d). Translate to 0,0 and\n    // measure the bounding rect.\n    if (!positionedBy.vertically) {\n      this.style.top = '0px';\n    }\n    if (!positionedBy.horizontally) {\n      this.style.left = '0px';\n    }\n    // It will take in consideration margins and transforms\n    var rect = this.getBoundingClientRect();\n    var fitRect = this.__getNormalizedRect(this.fitInto);\n    if (!positionedBy.vertically) {\n      var top = fitRect.top - rect.top + (fitRect.height - rect.height) / 2;\n      this.style.top = top + 'px';\n    }\n    if (!positionedBy.horizontally) {\n      var left = fitRect.left - rect.left + (fitRect.width - rect.width) / 2;\n      this.style.left = left + 'px';\n    }\n  },\n\n  __getNormalizedRect: function(target) {\n    if (target === document.documentElement || target === window) {\n      return {\n        top: 0,\n        left: 0,\n        width: window.innerWidth,\n        height: window.innerHeight,\n        right: window.innerWidth,\n        bottom: window.innerHeight\n      };\n    }\n    return target.getBoundingClientRect();\n  },\n\n  __getOffscreenArea: function(position, size, fitRect) {\n    var verticalCrop = Math.min(0, position.top) +\n        Math.min(0, fitRect.bottom - (position.top + size.height));\n    var horizontalCrop = Math.min(0, position.left) +\n        Math.min(0, fitRect.right - (position.left + size.width));\n    return Math.abs(verticalCrop) * size.width +\n        Math.abs(horizontalCrop) * size.height;\n  },\n\n\n  __getPosition: function(\n      hAlign, vAlign, size, sizeNoMargins, positionRect, fitRect) {\n    // All the possible configurations.\n    // Ordered as top-left, top-right, bottom-left, bottom-right.\n    var positions = [\n      {\n        verticalAlign: 'top',\n        horizontalAlign: 'left',\n        top: positionRect.top + this.verticalOffset,\n        left: positionRect.left + this.horizontalOffset\n      },\n      {\n        verticalAlign: 'top',\n        horizontalAlign: 'right',\n        top: positionRect.top + this.verticalOffset,\n        left: positionRect.right - size.width - this.horizontalOffset\n      },\n      {\n        verticalAlign: 'bottom',\n        horizontalAlign: 'left',\n        top: positionRect.bottom - size.height - this.verticalOffset,\n        left: positionRect.left + this.horizontalOffset\n      },\n      {\n        verticalAlign: 'bottom',\n        horizontalAlign: 'right',\n        top: positionRect.bottom - size.height - this.verticalOffset,\n        left: positionRect.right - size.width - this.horizontalOffset\n      }\n    ];\n\n    if (this.noOverlap) {\n      // Duplicate.\n      for (var i = 0, l = positions.length; i < l; i++) {\n        var copy = {};\n        for (var key in positions[i]) {\n          copy[key] = positions[i][key];\n        }\n        positions.push(copy);\n      }\n      // Horizontal overlap only.\n      positions[0].top = positions[1].top += positionRect.height;\n      positions[2].top = positions[3].top -= positionRect.height;\n      // Vertical overlap only.\n      positions[4].left = positions[6].left += positionRect.width;\n      positions[5].left = positions[7].left -= positionRect.width;\n    }\n\n    // Consider auto as null for coding convenience.\n    vAlign = vAlign === 'auto' ? null : vAlign;\n    hAlign = hAlign === 'auto' ? null : hAlign;\n\n    if (!hAlign || hAlign === 'center') {\n      positions.push({\n        verticalAlign: 'top',\n        horizontalAlign: 'center',\n        top: positionRect.top + this.verticalOffset +\n            (this.noOverlap ? positionRect.height : 0),\n        left: positionRect.left - sizeNoMargins.width / 2 +\n            positionRect.width / 2 + this.horizontalOffset\n      });\n      positions.push({\n        verticalAlign: 'bottom',\n        horizontalAlign: 'center',\n        top: positionRect.bottom - size.height - this.verticalOffset -\n            (this.noOverlap ? positionRect.height : 0),\n        left: positionRect.left - sizeNoMargins.width / 2 +\n            positionRect.width / 2 + this.horizontalOffset\n      });\n    }\n\n    if (!vAlign || vAlign === 'middle') {\n      positions.push({\n        verticalAlign: 'middle',\n        horizontalAlign: 'left',\n        top: positionRect.top - sizeNoMargins.height / 2 +\n            positionRect.height / 2 + this.verticalOffset,\n        left: positionRect.left + this.horizontalOffset +\n            (this.noOverlap ? positionRect.width : 0)\n      });\n      positions.push({\n        verticalAlign: 'middle',\n        horizontalAlign: 'right',\n        top: positionRect.top - sizeNoMargins.height / 2 +\n            positionRect.height / 2 + this.verticalOffset,\n        left: positionRect.right - size.width - this.horizontalOffset -\n            (this.noOverlap ? positionRect.width : 0)\n      });\n    }\n\n    if (vAlign === 'middle' && hAlign === 'center') {\n      positions.push({\n        verticalAlign: 'middle',\n        horizontalAlign: 'center',\n        top: positionRect.top - sizeNoMargins.height / 2 +\n            positionRect.height / 2 + this.verticalOffset,\n        left: positionRect.left - sizeNoMargins.width / 2 +\n            positionRect.width / 2 + this.horizontalOffset\n      });\n    }\n\n    var position;\n    for (var i = 0; i < positions.length; i++) {\n      var candidate = positions[i];\n      var vAlignOk = candidate.verticalAlign === vAlign;\n      var hAlignOk = candidate.horizontalAlign === hAlign;\n\n      // If both vAlign and hAlign are defined, return exact match.\n      // For dynamicAlign and noOverlap we'll have more than one candidate, so\n      // we'll have to check the offscreenArea to make the best choice.\n      if (!this.dynamicAlign && !this.noOverlap && vAlignOk && hAlignOk) {\n        position = candidate;\n        break;\n      }\n\n      // Align is ok if alignment preferences are respected. If no preferences,\n      // it is considered ok.\n      var alignOk = (!vAlign || vAlignOk) && (!hAlign || hAlignOk);\n\n      // Filter out elements that don't match the alignment (if defined).\n      // With dynamicAlign, we need to consider all the positions to find the\n      // one that minimizes the cropped area.\n      if (!this.dynamicAlign && !alignOk) {\n        continue;\n      }\n\n      candidate.offscreenArea =\n          this.__getOffscreenArea(candidate, size, fitRect);\n      // If not cropped and respects the align requirements, keep it.\n      // This allows to prefer positions overlapping horizontally over the\n      // ones overlapping vertically.\n      if (candidate.offscreenArea === 0 && alignOk) {\n        position = candidate;\n        break;\n      }\n      position = position || candidate;\n      var diff = candidate.offscreenArea - position.offscreenArea;\n      // Check which crops less. If it crops equally, check if at least one\n      // align setting is ok.\n      if (diff < 0 || (diff === 0 && (vAlignOk || hAlignOk))) {\n        position = candidate;\n      }\n    }\n\n    return position;\n  }\n\n};\n","/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n\nimport {Polymer} from '@polymer/polymer/lib/legacy/polymer-fn.js';\nimport {dom} from '@polymer/polymer/lib/legacy/polymer.dom.js';\nimport {html} from '@polymer/polymer/lib/utils/html-tag.js';\n\n/*\n`iron-overlay-backdrop` is a backdrop used by `Polymer.IronOverlayBehavior`. It\nshould be a singleton.\n\n### Styling\n\nThe following custom properties and mixins are available for styling.\n\nCustom property | Description | Default\n-------------------------------------------|------------------------|---------\n`--iron-overlay-backdrop-background-color` | Backdrop background color | #000\n`--iron-overlay-backdrop-opacity`          | Backdrop opacity | 0.6\n`--iron-overlay-backdrop`                  | Mixin applied to `iron-overlay-backdrop`.                      | {}\n`--iron-overlay-backdrop-opened`           | Mixin applied to `iron-overlay-backdrop` when it is displayed | {}\n*/\nPolymer({\n  _template: html`\n    <style>\n      :host {\n        position: fixed;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        background-color: var(--iron-overlay-backdrop-background-color, #000);\n        opacity: 0;\n        transition: opacity 0.2s;\n        pointer-events: none;\n        @apply --iron-overlay-backdrop;\n      }\n\n      :host(.opened) {\n        opacity: var(--iron-overlay-backdrop-opacity, 0.6);\n        pointer-events: auto;\n        @apply --iron-overlay-backdrop-opened;\n      }\n    </style>\n\n    <slot></slot>\n`,\n\n  is: 'iron-overlay-backdrop',\n\n  properties: {\n\n    /**\n     * Returns true if the backdrop is opened.\n     */\n    opened: {\n      reflectToAttribute: true,\n      type: Boolean,\n      value: false,\n      observer: '_openedChanged',\n    }\n\n  },\n\n  listeners: {\n    'transitionend': '_onTransitionend',\n  },\n\n  created: function() {\n    // Used to cancel previous requestAnimationFrame calls when opened changes.\n    this.__openedRaf = null;\n  },\n\n  attached: function() {\n    this.opened && this._openedChanged(this.opened);\n  },\n\n  /**\n   * Appends the backdrop to document body if needed.\n   */\n  prepare: function() {\n    if (this.opened && !this.parentNode) {\n      dom(document.body).appendChild(this);\n    }\n  },\n\n  /**\n   * Shows the backdrop.\n   */\n  open: function() {\n    this.opened = true;\n  },\n\n  /**\n   * Hides the backdrop.\n   */\n  close: function() {\n    this.opened = false;\n  },\n\n  /**\n   * Removes the backdrop from document body if needed.\n   */\n  complete: function() {\n    if (!this.opened && this.parentNode === document.body) {\n      dom(this.parentNode).removeChild(this);\n    }\n  },\n\n  _onTransitionend: function(event) {\n    if (event && event.target === this) {\n      this.complete();\n    }\n  },\n\n  /**\n   * @param {boolean} opened\n   * @private\n   */\n  _openedChanged: function(opened) {\n    if (opened) {\n      // Auto-attach.\n      this.prepare();\n    } else {\n      // Animation might be disabled via the mixin or opacity custom property.\n      // If it is disabled in other ways, it's up to the user to call complete.\n      var cs = window.getComputedStyle(this);\n      if (cs.transitionDuration === '0s' || cs.opacity == 0) {\n        this.complete();\n      }\n    }\n\n    if (!this.isAttached) {\n      return;\n    }\n\n    // Always cancel previous requestAnimationFrame.\n    if (this.__openedRaf) {\n      window.cancelAnimationFrame(this.__openedRaf);\n      this.__openedRaf = null;\n    }\n    // Force relayout to ensure proper transitions.\n    this.scrollTop = this.scrollTop;\n    this.__openedRaf = window.requestAnimationFrame(function() {\n      this.__openedRaf = null;\n      this.toggleClass('opened', this.opened);\n    }.bind(this));\n  }\n});\n"],"mappings":";AA8DA;;;;;;;;;;;;;;;;;;;;;;;ACLA","sourceRoot":""}